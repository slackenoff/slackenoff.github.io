{"pages":[],"posts":[{"title":"博客搭建过程记录","text":"记录下hexo+github博客搭建过程 1. 第一步 github创建repo命名规范如： githubusername.github.io，不能自定义。 2. 第二步 本地配置主要有2部分，node+hex的环境搭建及部署，git+github的环境搭建及部署。 2.1 先安装node，node网址，配置环境变量 ，添加path 2.2 指定一个目录，进入终端，在该目录下执行 ： npm install -g hexo 默认这个目录就是hexo的根目录 2.3 本地服务配置命令 初始化： hexo init 生成默认的hexo模板： hexo g 启动本地预览服务，-p指定端口： hexo server -p 5000 （默认是4000） 2.4 默认的主题很简约，所以可以考虑改主题,这是 主题的官网地址 , 在根目录下，打卡bash终端， git clone [主题的github地址] themes/[主题名] 默认会下载到hexo的themes目录下，文件夹名为[主题名]，按照对应仓库下的readme.md文件，配置yml。 2.5 修改完，刷新本地的静态页面，观察效果 3.第三步 上传github仓库hexo d 上传配置到github的repo 3.1 git配置 git config user.email &quot;&quot; &lt;br&gt; git config user.name &quot;&quot; ssh-keygen -t rsa -C &quot;邮箱地址&quot; github设置中，修改ssh的绑定信息 ————————————-配置完成 4. 第四步 上传远端仓库 hexo clean hexo d -g 5. 至此就可以访问xxx.github.io了，如果不能正常访问，可以考虑主题文件缺失，或者配置有误，一般是低级错误导致的","link":"/2023/04/02/2023-4-2-%E9%9A%8F%E7%AC%94/"},{"title":"Ruby","text":"Ruby语言初体验 标准输入输出 puts 基本数据类型数值： 整型： fixnum 、 bignum 浮点： 字符串： 数组：[] 哈希类型：{} 范围类型: start..end 包含边界 start...end 不包含end 注释 # 单行注释 =begin 多行注释 =end 关键字| BEGIN | do | next | then | end | | else | nil | true |alias | elsif | | not | undef| and |END | or | | unless| begin| ensure| redo | until | | break | false| rescue | when | case | |case | for | retry | while | class | |if | return | yield | def | in | |self | _FILE_ | defined? | module | super | _LINE_ | 空格空格在除字符串的地方，会被忽略 标识符大小写敏感 BEGINBEGIN{ CODE # code将在程序运行前调用 } ENDEND{ CODE # code将在程序的结尾被调用 } 类class Customer # 类名 首字母大写 end 变量全局变量： $ 类变量： @@ 实例变量： @ 局部变量： 小写字母或 _ 开始 对象obj_name=Class.new # 创建对象 方法def func # 小写字母开头 end","link":"/2023/09/12/Ruby/"},{"title":"batch","text":"batch学习的四步 熟悉专用命令 熟悉特殊符号与批处理 熟悉批处理与变量 编写bat脚本 查看bat命令手册 command /? &lt;!—&gt; 1. 专用命令echo 在命令行界面输出文本 set 设置变量 if 条件判断 for 循环操作 goto 跳转命令 REM 注释 :: 注释 @ 控制回显输出 pause 在此处暂停 title 修改cmd的标题 errorlevel 获取bat文件的执行状态，0代表执行成功，1代表执行失败 color 不重要 mode : find start assoc ftype pushd popd call shift setlocal attrib 2. 特殊符号@ 命令行回显屏蔽符 % 批处理变量引导符 %% 指定一个第一字母可替换的参数 &gt; 重定向符 &gt;&gt; 重定向符 &lt; 重定向符 &gt;&amp; 重定向符 &lt;&amp; 重定向符 | 管道命令 ^ 转义字符 &amp; 组合命令 &amp;&amp; 组合命令 || 组合命令 &quot;&quot; 字符串界定符 , 逗号 ; 分号 () 括号 ! 感叹号 2. 数学运算，比较运算符SET /A expression set /a count=6 echo %count% 6 SET /P variable=[promptString] set /p count=&quot;请输入一个数字&quot; 请输入一个数字6 echo %count% 6 EQU,NEQ,GTR,LSS,LEQ,GEQ 时间，日期比较 if not 3 equ 4 echo true true if 3 neq 4 echo true true if not 3 gtr 4 echo true true if 3 lss 4 echo true true if not 3 geq 4 echo true true if 3 leq 4 echo true true == 字符串比较 if [not] 'abc' == 'abc' echo true true 3. 文件处理3.1 dir /?语法规范：DIR [drive:][path][filename] [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N] [/O[[:]sortorder]] [/P] [/Q] [/R] [/S] [/T[[:]timefield]] [/W] [/X] [/4] [drive:][path][filename] 用法1： dir /ad 只输出路径下所有的目录名，最后修改时间，目录大小 dir /a-d 除目录外，其他的对象均输出，对象名，最后修改时间，对象大小 dir /o 按分类顺序列出文件 /oN 按名称，字母顺序 /o-N 按名称，字母倒序 /oS 按大小，从小到大 /o-S 按大小，从大到小 /oD 按时间，从先到后 /o-D 按时间，从后到先 /T：C/A/W C创建时间， A 上次访问时间， W 上次写入的时间 3.2 for /?语法规则： FOR %variable IN (set) DO command [command-parameters] 用法1： for %i in (1,1,5) do set /a count=count+%i 结果如下： set /a count=count+1 2 set /a count=count+1 3 set /a count=count+5 8 用法2： for /l %i in (1,1,5) do set /a count=count+%i 结果如下： set /a count=count+1 9 set /a count=count+2 11 set /a count=count+3 14 set /a count=count+4 18 set /a count=count+5 23 特殊用法：1. 文件夹带空格，用双引号把文件夹名括起来&quot;&quot; 2. for循环中，使用 | 管道命令时， 需要写为 ^| 3. 多重判断 if a&gt;b if(c&gt;d echo xx) 是 且的关系，2个条件同时成立时，执行，否则不执行。 多重判断 if a&gt;b if(c&gt;d echo xx) else (if a&gt;c if(c&gt;d echo xx)) 是 或的关系，当a大于b或者c时，执行且的部分，否则不执行 小案例创建定时任务 关于路径的说明， /（非标准） 与 \\（windows的标准分隔符）标准的 DOS 路径可由以下三部分组成： 1. 卷号或驱动器号，后跟卷分隔符 (:)。 2. 目录名称。 目录分隔符用来分隔嵌套目录层次结构中的子目录。 3. 可选的文件名。 目录分隔符用来分隔文件路径和文件名。 如果以上三项都存在，则为绝对路径。 如未指定卷号或驱动器号，且目录名称的开头是目录分隔符，则路径属于当前驱动器根路径上的相对路径 注意点： C:\\Projects\\apilibrary\\apilibrary.sln C: 驱动器的根目录中的文件的绝对路径。 C:Projects\\apilibrary\\apilibrary.sln C: 驱动器的当前目录中的相对路径。 通用命名约定 (UNC) 路径，用于访问网络资源，具有以下格式： 一个以 \\\\ 开头的服务器名或主机名。 服务器名称可以为 NetBIOS 计算机名称或者 IP/FQDN 地址（支持 IPv4 和 IPv6）。 共享名，使用 \\ 将其与主机名分隔开。 服务器名和共享名共同组成了卷。 目录名称。 目录分隔符用来分隔嵌套目录层次结构中的子目录。 可选的文件名。 目录分隔符用来分隔文件路径和文件名。","link":"/2023/09/24/batch/"},{"title":"Git教程","text":"为什么要用版本控制 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。简单来说就是用于管理多人协同开发项目的技术 ● 实现跨区域多人协同开发 ● 追踪和记载一个或者多个文件的历史记录 ● 组织和保护你的源代码和文档 ● 统计工作量 ● 并行开发、提高开发效率 ● 跟踪记录整个软件的开发过程 ● 减轻开发人员的负担，节省时间，同时降低人为错误 版本控制的策略（都受制于网络）集中式版本控制：vss，cvs ，svn； 资源在中央服务器 分布式版本控制： git ； 资源在本地环境有中央服务器的副本 版本控制策略的优劣优势： 缺陷： 文件冲突 为什么选择Git来做版本控制优势 操作1. 仓库操作2. 文件操作3. 分支原理及操作： 分支是下载在本地的副本，使用分支可以减少文件冲突，以及修改合并操作，只需要关心最终合并。本质上是引用文件切换，head文件指向分支，分支指向具体提交的版本号。4. 标签5. 版本号： sha-1自动生成的40位（2位 文件夹+38位 文件名）6. 追溯文件： git cat-file 版本号具体的指令（远程仓库 -》 本地副本[工作区 -》 暂存区 -》 存储区域] -》 远程仓库）1. git init --创建一个空的本地仓库 2. git clone 仓库地址 --克隆仓库 3. git add --添加到暂存区 4. git status --查看暂存区比对信息 5. git commit -m 备注 --提交到存储区 6. git log --oneline --查看历史变更日志 7. git restore 或 git reset --hard 版本号 或者git revert 恢复文件 8. git branch 分支名 --创建分支 9. git branch -v 查看所有分支 10. git checkout -b 分支名 --创建并切换到本地分支 11. git branch -d 分支名 --删除本地分支 12. git merge 要合并的分支 --合并分支 13. git push origin --拉 14. git pull origin --推","link":"/2023/05/04/Git%E6%95%99%E7%A8%8B/"},{"title":"JAVA入门","text":"人生苦短，我学java，230920 今天跟开发对接，因为不专业，几十分钟的事情，拖了一下午，汗颜 知识点1 JDKJDK概念 java development kit 开发工具包，开发用的，集成了jre； JDK结构 windows 执行 tree /f 知识点2 JREJRE概念 java runtime environment 运行时环境，用来运行java程序代码的； JRE结构 知识点3 JARJAR概念 java archive file ，是一种与平台无关的文件格式，压缩格式为zip，形式上等同于zip，但内容上，作为引用对象的jar包含有meta-inf/menifest.mf文件，作为可执行对象的jar包含有main-class和class-path。 Jar内容 Jar包的使用 运行jar包 java -jar xx.jar 打包 知识点4 WARWAR概念 web archive file 也是与平台无关的文件格式，它是一个可以运行的web模块，是web应用程序 WAR结构 知识点5 JDK11之后，jre不再是默认安装，需要命令生成bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre 知识点6 .java .class.java java源文件，是文本文件 .class 二进制字节码文件，由.java解析而来 vscode配置java settingsctrl+shift+p 打开全局搜索 输入java overview 进入java的配置模块 搜索java home,进入settings.json配置","link":"/2023/09/20/JAVA%E5%85%A5%E9%97%A8/"},{"title":"linux命令","text":"linux是助推器，影响个人在IT赛道上的speed推荐一个我认为比较实用的查询网站linux命令搜索 写在前面的话 1. 什么是linux linux是服务器领域最常用的多用户、多任务操作系统，开源免费，有诸多的发行版，常见的有redhat，centos，ubuntu等 linux系统启动过程简要介绍以及linux核心——内核的功能简要描述 启动过程： 1. 内核引导: 开机bios自检，按照bios设定的启动设备启动，一般是硬盘，硬盘激活后，操作系统接管，读取/boot 目录下的内核文件(镜像、压缩包等) 2. init进程： 运行init进程，它是所有进程的起点，操作系统在/etc/inittab目录下读取init进程的配置文件；如windows系统的一些开机即启动的服务一样，linux 的守护进程 daemon需要开机启动，init进程的一大任务就是运行开机启动的程序。 linux允许为不同的场合分配不同的开机启动程序，这个过程叫做分配运行级别，系统启动时根据运行级别，确定运行哪些程序；linux共设有7个运行级别 3. 系统初始化： 调用rc.d目录下的shell脚本完成系统初始化工作，看网上的说法，调用了./rc.sysinit，但是没找到，只找到了rc0-6.d/。看了下init.d的readme，似乎是被systemctl相关的服务取代了。 这个脚本的作用是 激活交换分区，检查磁盘，加载硬件模块以及一些其他需要优先执行的任务。初始化过程中的第一个进程是systemd，pid是1. 4. 建立终端： rc脚本执行完毕后，返回init进程，【运行mingetty程序，打开终端，设置模式】，以便用户登录系统。 5. 用户接入 2. 什么是shell？ 有什么功能？ linux默认使用什么shell？ shell是交互式工具，也称解释器，是用户与linux沟通的桥梁，它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径；默认的shell都是bash 辅助命令或常识 FHS File System Hierarchy Standard 文件系统层次结构标准 man hier bin 存放二进制的可执行程序 boot 系统引导时使用的文件 dev 存放设备文件，通过设备文件访问外部设备 etc 系统配置文件 home 所有用户的根目录，8个用户则有8个对应的/home/dir1..8 lib 存放根文件系统中的程序运行所需要的共享库及内核模块 mnt 临时文件系统的挂载点目录 media 即插即用型存储设备的挂载点，如cd，dvd opt 第三方软件的存放目录 proc 虚拟文件系统，存放当前内存的映射，再不重启机器的情况下管理内核 root 管理员用户目录 sbin 管理员才能访问的存放二进制可执行文件的目录，同bin srv 系统对外提供服务的目录 tmp 放置各种临时文件的目录 usr 存放系统应用程序 var 存放需要随时改变的文件，如系统日志，脱机工作目录等 文件类型及其颜色： 1. 普通文件 灰色 || 可执行文件 绿色 || 压缩文件 红色 ls -l 查看为 - 2. 目录文件 蓝色 ls -l 查看为 d 3. 设备文件 黄色 /dev/.. 块设备文件 b 硬盘软盘 随机访问设备 + 字符设备文件 c 串口、键盘 顺序访问设备 4. 链接文件 浅蓝色 ls -l 查看时，显示为 “|” 软链接（源文件的快捷方式，源动，链接动） 和 硬链接 （源文件别名，无论源动还是链接动，另一方都会改变），默认硬链接 。 5. 管道文件 棕色 用于进程间通信 ls -l 查看为 p 6. 套接字文件 紫色 用于网络通信 ls -l 查看为 s /文本 --查询文本 n/N --向后向前搜索 pageUp/Down --向上向下翻页 ctrl+C --结束执行 help command --查看命令文档 man [1..9] --查看不同手册页，存放路径 /usr/share/man/.. findmnt --查看已经挂载的文件系统、 df -Ph --显示磁盘剩余空间 fdisk -l --显示磁盘分区 firewall-cmd --list-all 显示防火墙规则 yum repolist --查看已启用的软件更新源 yum list installed --查看已安装的所有软件 yum check-update/yum list updates --查看可更新 localectl /etc/locale.conf 返回示例：LANG=&quot;zh_CN.UTF-8&quot; --control the system locale [语言环境] and keyboard layout [键盘模式] settings localectl status --查看本地语言环境设置 localectl set-locale LANG=&quot;&quot; --设置语言环境 localectl list-locales --查看常见的(官方用词known)语言环境 .. 硬件时钟（RTC）和系统时钟(SC): /etc/localtime RTC-主板上显示的时间 SC-内核时钟（操作系统实际使用，采用UTC时间） 国内CST 和 UTC（0时区） 差8个小时 timedatectl query or change system time and date settings timedatectl status timedatectl set-timezone ZONE=&quot;&quot; timedatectl set-time &quot;时间/年月/时间年月组合&quot; shutdown [shutdown -c 取消shutdown] [shutdown -k 发送关机计划提示，默认是分钟] 系统关闭断电 halt = shutdown -h 系统关闭不断电 poweroff = shutdown -P 系统关闭，断电 最终都是执行 systemctl[/usr/sbin] poweroff/reboot/halt shutdown -[options] [+]5[minutes] “警示语” 【似乎临近重启时间，每分钟都会提示】 whoami --查看当前用户身份 id --查看当前用户的id信息，用户id，组id等 groups --查看用户所属的组 cal --显示日历 df --文件系统磁盘空间使用情况 du --指定文件或目录已占用的磁盘空间 &lt;tab&gt;键 --自动命令补全，补全的对象包括[命令名]、[shell变量]、[用户名]、[主机名]、[目录或文件名] ！！ --执行【最近】一次执行的命令，也就是上一条命令 ！[命令事件编号] --执行指定的历史命令 包管理命令：rpm、apt、yum、dnf(fedora) 包管理的功能大致归纳为5部分： 安装、卸载、升级、查询、验证 noarch： 表示已编译的代码与平台无关 epel： Extra Packages for Enterprise Linux。EPEL 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL 之后，就相当于添加了一个第三方源。 epel、repoforge、remi、Nginx、ownCloud、oVirt、RDO 知名的非官方仓库，gpgcheck是出于下载安全考虑的，当存在需要使用非官方仓库的软件包时，认准有gpg签名的非官方仓库。 ***出处链接：https://www.jianshu.com/p/6a71714342e3*** yum介绍yellow dog updater,modifiedyum是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum语法： yum [选项] [参数]选项： -h：显示帮助信息； -y：对所有的提问都回答“yes”； -c：指定配置文件； -q：安静模式； -v：详细模式； -d：设置调试等级（0-10）； -e：设置错误等级（0-10）； -R：设置yum处理一个命令的最大等待时间； -C：完全从缓存中运行，而不去下载或者更新任何头文件。 参数： install：安装rpm软件包； update：更新rpm软件包； check-update：检查是否有可用的更新rpm软件包； remove：删除指定的rpm软件包； list：显示软件包的信息； search：检查软件包的信息； info：显示指定的rpm软件包的描述信息和概要信息； clean：清理yum过期的缓存，clean all； shell：进入yum的shell提示符； resolvedep：显示rpm软件包的依赖关系； localinstall：安装本地的rpm软件包； localupdate：显示本地rpm软件包进行更新； deplist：显示rpm软件包的所有依赖关系。 --installroot=path 常见用法： yum check-update 查看可更新的所有软件包 yum update 下载更新已安装的所有软件包 yum search name:version 查找软件包 yum list installed 查看已安装的软件包 yum info name 软件包详情 yum install name 下载软件包 yum update name 更新软件包 yum remove name 删除软件包相关路径及操作： 主配置文件：/etc/yum.conf 注： cachedir 缓存目录 logfile 日志文件路径 官方仓库： base、updates、extras、cenosplus 配置文件/etc/yum.repos.d/*.repo 启用或禁用仓库： method1： 修改配置文件，enabled =0 / 1 method2： yum-config-manager –enable/disable repo_name 了解： yum-plugin-fastestmirror插件是默认安装启动的，所以yum命令默认会从镜像地址列表中选择一个速度最快的镜像地址，并从该地址获取软件包 apt-get介绍apt-get命令 是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。 apt-get语法：apt-get [选项] 选项： apt-get install # 安装新包 apt-get remove # 卸载已安装的包（保留配置文件） apt-get purge # 卸载已安装的包（删除配置文件） apt-get update # 更新软件包列表 apt-get upgrade # 更新所有已安装的包 apt-get autoremove # 卸载已不需要的包依赖 apt-get dist-upgrade # 自动处理依赖包升级 apt-get autoclean # 将已经删除了的软件包的.deb安装文件从硬盘中删除掉 apt-get clean # 删除软件包的安装包 -c：指定配置文件。 – 执行命令重现的一对命令： script 以及scriptreplay 网络配置与包管理 要明确的基本问题 1. 网络配置的内容有哪些？ IP地址 子网掩码 默认网关 dns ... 2. 配置方式有哪些？ 静态手工配置 DHCP服务动态获取 3. 实操 a) 了解常见的网络接口： 以太网接口eth、无线网络接口wlan、光纤分布式数据接口 fddi、点对点协议接口 ppp、本地回环接口 lo b) 网络设备名： en 以太网设备、wl 无线局域网设备、ww 无线广域网设备 c) 硬件类型： o 主板板载设备、 s 热插拔插槽上的设备 、p pci总线或者usb接口上的设备 3.1 使用IP命令查看并更改IP网络地址 ip addr show / ip a s --查看全部接口的IP地址 ip [-4/-6] a s [指定接口名] --指定接口的IP地址 ip route show --显示路由 ip neighbor show --显示arp缓存 //修改IP地址 ip addr [add/del] [ip地址] dev [网络设备接口] //修改静态路由 ip route [add/del] [主机地址] via [网关地址] dev [网络设备接口] 3.2 配置TCP/IP网络 a) 配置文件的路径 cat /etc/sysconfig/network-scripts/ifcfg-* 网络接口配置文件 type： 接口类型 defroute: 是否设置默认路由 ipv4_failure_fatal IPv4地址配置失效，及时IPv6配置正确也禁用该设备 bootprotocol 获取网络参数的方式 dhcp、static、none cat /etc/sysconfig/network-scripts/route-* 路由配置文件 cat /etc/hostname 本地主机名配置文件 cat /etc/hosts 主机名与IP地址的映射关系 cat /etc/metworks 域名与网络地址的映射 cat /etc/host.conf e.g. multi on 域名服务的客户端控制文件 cat /etc/resolv.conf 域名服务客户端的配置文件，用于指定服务器的位置 cat /etc/protocols 查看支持的协议、协议的协议号 cat /etc/services 查看支持的网络服务及其端口号 包转发 sysctl net.ipv4.ip_forward --查看是否支持包转发,如果没有或者是0，改为1； 3.3 nmcli networkmanager是一项管理网络接口和配置网络连接的系统服务，控制管理工具包括GUI、TUI、Cli 1. 显示所有网络接口设备的状态 nmcli -p [device] [status] 2. 显示指定网络接口设备的状态 nmcli -p device show ens33 3. 断开设备连接且置非自动连接状态 nmcli device disconnect ens33 4. 显示[激活的]所有连接 nmcli -p connection show [--active] 5. 显示指定连接的信息 nmcli -p connection show ens33 6. 激活指定网络接口上的连接 nmcli -p connection up id ens33 7. 激活指定接口上的连接配置,适用于定义了多个连接配置的情况 nmcli -p connection up &quot;my connection&quot; ifname ens33 8. 重新加载连接配置 nmcli connection reload 9. 修改IP地址获得方式 nmcli connection modify ens33 ipv4.method manaul // nmcli connection modify ens33 ipv4.method auto 10. 设置IP地址、网关和dns解析 nmcli -p connection modify ens33 ipv4.addresses 10.0.0.30/24 ipv4.gateway 10.0.0.1 ipv4.dns &quot;10.0.0.1 8.8.8.8&quot; 11. 添加或删除ipv4属性 nmcli connection modify ens33 +/-ipv4.addr/gateway/dns 基础架构服务守护进程和系统初始化 1. 系统守护进程： dbus、crond、cups、rsyslogd... 2. 网络守护进程: sshd、httpd、postfix、xinetd... 初始化进程： linux采用过3种初始化进程，sysVinit、Upstart、Systemd（centos7）服务管理命令 systemctl 部分功能与service 命令等效***********管理命令 systemctl start //启动服务 systemctl stop //停止服务 systemctl restart //重启服务 systemctl status // 查看服务运行状态 systemctl reload // 重新加载服务配置文件 systemctl is-active // 查看服务是否正在运行 systemctl –type service –failed //查看已加载但处于failed状态的服务 systemctl -at service // 显示所有服务***********持久化命令 systemctl enable //在系统启动时启用服务 systemctl disable //在系统启动时停用服务 systemctl list-unit-files –type service //查看服务的启停配置， static 灰、 enable 绿、disable 红 计划任务 cron、at、batch at： 一次性任务 在指定时间执行一次 batch： 一次性任务 在系统负载不重时执行一次 cron： 周期性任务 周期性计划任务 –cronie软件提供周期性计划任务服务，由cronie、cronie-anacron、crontabs 3部分组成 cronie： 提供crond守护进程及其配置目录 /etc/cron.d，以及crontab命令 cronie-aracron：提供由crond调用的anacron程序及其配置文件/etc/anacrontab crontabs：提供run-parts脚本以及依赖此脚本的系统计划任务配置文件/etc/crontab和配置目录/etc/cron.{daily,weekly,monthly}–crond进程工作原理 crond进程有内部计时器，每一分钟唤醒一次进程，检测文件变化并加载到内存中，具体文件为： 1. /etc/crontab 2. /etc/cron.d/* 3. /var/spool/cron/* //用户自定义定时任务目录 4. /etc/anacrontab 如果上述文件中的cron任务的时间和日期与系统当前时间和日期符合，执行对应的cron任务，任务执行结束后，输出将以邮件的形式发送给安排cron任务的用户，或者配置文件中mailto指定的用户注： 因为crond进程每分钟自动检测，所以对配置文件或目录的修改，不需要reload或者restart crontab文件格式： [分] [时] [日] [月] [周] [用户名] [命令] 共计7个字段 分： 0-59 时： 0-23 日： 1-31 月： 1-12 周： 0-7 0，7都指周日注: 多个值用【，】分割； 范围用【-】指定；范围步长用 【/n】表示；[]代表任何时间，每个字段均不能为空* –cron任务的创建及权限 /etc/cron.allow //如果存在，则只有文件中用户可以使用cron /etc/cron.deny //如果存在，则文件中的用户不能使用cron crontab -e 注： root用户不受约束注： 环境变量 ： path shell 解释器 mailto 指定用户 cat /etc/crontab [* * * * * * * root cmd] cat /etc/cron.d/0hourly 同上 cd /etc/cron.{daily,weekly,monthly} 在目录下放要执行的脚本–anacrontab /etc/anacrontab文件配置非周期性任务 网络测试工具 1. ping 命令 测试网络连通性，发送icmp请求包 || ICMP是一个网络层协议。用来检测IP报文是否能够正常发送，并反馈发送出错原因，以及查询主机的信息，也就是差错查询和信息查询 ping 域名 ping ip地址 2. ss 命令 显示套接字统计信息 ss -l 显示本地监听的socket ss -t 显示建立连接的tcp socket ss -u 显示建立连接的udp socket 3. lsof 命令 查看端口的进程，需要下载，不是内置的 yum search lsof || yum install -y lsof lsof -i :22 4. traceroute 命令 不是内置命令，需要下载 显示数据包到达目的主机所经过的路由 5. dig命令，可以测试dns服务器是否能正常工作 其他工具 ftp工具： lftp wget下载工具 links/w3m 字符界面浏览器 远程数据同步工具：rsync ，运行原理，首次同步时，全量同步，之后增量同步 远程登录： ssh 本地与远程主机间文件复制： scp sftp加密会话 centos重要的系统目录 1. cat /etc/os-release 查看系统版本 hostnamectl uname -a uname -r 2. cd /var/cache/yum 相关命令 yum makecache fast 将软件包信息提前在本地索引缓存，用来提高搜索安装软件的速度， yum clean all 清除索引缓存和下载包的缓存。 3. cd /etc/yum.repos.d 切换、查看yum镜像源的目录 vim xxx.repo 修改源配置文件 yum repolist 查看镜像源列表 源有： epel、extras、update、base 四种 4. 查看内核版本有三种方式： cat /proc/version uname -a uname -r 5. 用户配置信息丢失，登录非正常显示，如 bash-4.2 还原办法： 切换目录 cd /etc/skel ; 查看目录下的文件 ls -a; 复制 .bashrc .bash_profile 文件到 /root目录下 reboot 文件目录cmd 1. 查看 查看当前工作路径： pwd 查看文件和目录列表： ls -al 以长格式[l]显示当前路径下，全部[a]文件和目录（包含隐含文件、目录） 查找指定文件： find &quot;name.extend&quot; || find *.txt || find [查找的目录] -name '前缀*' 查看文件内容： cat/tac 文件名 分页查看文件内容： more/less 文件名 显示前、后n行内容： head/tail -n 文件名 统计文本内容： wc -lwm 文件名 [l 行 m 字符数 w word counts] 查看文件类型： file 文件名 2. 创建 touch file1，file2 创建2个空文件，0字节 echo &gt; file1 覆盖，没有则创建 echo &gt;&gt; file1 添加，没有则创建 3. 修改 vi mv name1 name2 将名为name1的文件或目录 改为name2 4. 删除 rm -f file{1，3，5} 强制删除 rm -r dir/ 提醒删除目录及其内容 rmdir 删除目录 5. 链接 ln a b 硬链接 b为链接 ln -s a b 软/符号链接 b为链接 6. 复制 cp [待复制内容] [目标目录] 时间戳： atime 最后访问 ls -lu，ctime 最后改变 ls -lc，mtime 最后修改 ls -lt 7. 打包 【多-&gt; 一，以便备份/传输】 、压缩 【大-&gt; 小 以便减少磁盘占用/传输】、解压 【小-&gt;大】 压缩格式 gzip，bzip2，xz tar -c 创建 -r 添加 -t 罗列 -u 更新旧内容 -x 解压 -v 打包解压进度 tar -cvf 包名.格式 [打包文件] 创建 tar -xvf 包名.格式 extract gzip 文件 压缩文件 gzip -d *.gz 解压文件 三剑客 grep 文本处理工具 与sed、awk实用命令 windows下的文件比对工具，如beyondCompare、ultraCompare （收费）， Winmerge（免费） ，或者文本编辑器下插件（如notepad++，vscode,sublime等）linux下diff命令，或者meld工具 diff 命令 diff【2个文件，不带参数时，描述如何调整第一个文件来与第二个文件想匹配】 -q或--brief // 仅显示有无差异，不显示详细的信息 如果不同，输出Files a and b differ -c // 显示全部内容，并标出不同之处， ！ + - *** 代表 第一个文件 --- 代表 第二个文件 ！ 需要在第一个文件修改一行或多行 + 需要在第一个文件添加行 - 需要在第一个文件删除行 注： 默认输出须知 diff [不带参] (a：添加， c：改变 ，d：删除） &lt; 开头的行表示来自第一个文件 &gt; 开头的行表示来自第二个文件 diff3【3个文件】 比较三个文件，将不同之处显示到标准输出 -A 注： ====表示文件全不相同 ====3表示 第3个文件与其他2个不同 sort命令 sort -r 按逆序输出排序结果 以行首字母为排序对象 -c 检查指定文件中的内容是否按字母顺序排序，不符合则输出 sort: 文件名：行号： disordr: 无序内容 awk命令sed命令chmod命令，配合ll命令查看文件权限 a) 第一位 文件类型 b) 权限前3位 文件所有者的权限 c) 权限中间3位 文件所属用户组的权限 d) 权限后3位 其他用户的权限 e) 其次是连接数 f) 所属用户 g) 所属用户组 h) 文件大小 i) 文件最后修改日期 j) 文件名 chmod 【a[所有人]u[文件拥有者]g[拥有者所属用户组]o[其他用户]】【+-=】【rwx】文件 chmod 【a[所有人]b[拥有者所属的用户组]c[其他用户]】【+-=】【r=4，w=2，x=1，-=0】 Kill -9 pid 与 kill -15 pid 9，是强制执行系统信号，pid进程接到信号必须结束运行，可能导致数据丢失或者终端无法恢复到正常状态等 15，先释放资源，再结束进程 echo 1. 普通终端输出，后面跟什么，输出什么 如： echo 123 终端输出123 2. 命令执行结果终端输出，输出命令执行结果 如： echo &quot;`ifconfig`&quot; 终端输出ifconfig网络信息,带 &quot;&quot; 等同于 ifconfig， 不带&quot;&quot;时，非格式化输出，不便于查看 3. 如果文件存在，则覆盖写入，否则先创建，再写入。 如： 1. echo &quot;echo &quot;`ifconfig`&quot;&quot;&gt; test.sh 2. cat test.sh 发现获取的是本地网络信息 3. 修改为 echo &quot;ifconfig&quot; &gt;test.sh 4. cat test.sh 发现只有一行ifconfig 5. 执行脚本报错，没有执行权限 6. 修改权限，chmod 777 test.sh 补充： 1. 修改某类型文件,多种类型用空格分开： chmod 777 *.txt *.html *.sh 2. 修改某个文件目录下的全部文件权限： chmod 777 /dir/dir1 或者切换到该目录 chmod（a） 777 * 3. 默认是 chmod是对所有人 即all， 否则需要写ugo+-=rwx 7.执行 ./test.sh，输出结果等效ifconfig if、ifconfig 配置和显示Linux内核中网络接口的网络参数 返回信息如： ens33: 连接类型、 硬件地址；网卡IP、广播地址、子网掩码；网卡启停，网线接入状态，是否支持组播，最大传输单元（字节） lo: 主机的回环地址，测试用 ifconfig ens33 up 启动指定网卡 ifconfig ens33 down 关闭指定网卡 ifconfig ens33 [点分十进制ip地址] netmask [子网掩码] broadcast [广播地址] hostname 查看和修改主机名 即 root@xxx 中的xxx，hostname的改动是临时的，永久改动要用hostnamectl hostnamectl status 查看当前主机名设置 hostnamectl set-hostname xxx 要重启 //主机名保存在 /etc/hostname中 route 本地路由表 destination： 可路由的IP gateway： 区分直连或非直连，直连0.0.0.0 非直连 显示网关IP genmask： 目标网络的掩码 metric： 路由开销，值越小，优先级越高 Iface： 从哪个网卡发出的请求 常用： route -n 不用代名词，以数字显示IP route add -net [] gw [] route del -net [] netstat -a : 显示所有活跃的网络连接 -r ： 路由表 等于 route -n -t ： tcp协议相关 -u ： udp协议相关 -l : 处于监听状态的网络连接及端口信息 -p ： 显示与网络连接相关联的进程号、进程名称信息 netstat -atlp/aulp netstat -r ps、pidof、pgrep 查看进程 ps -u root 查看root用户的进程信息 ps auxw || ps -efw 查看所有运行的进程, w查看完成命令信息 进程信息： pid、ppid 父进程、tty 启动进程的终端、stat 当前状态 start 启动时间 vsz 占用的虚拟内存空间 kb rss 占用的内存空间 kb time 进程启动后占用的cpu时间 user 用户名 size 进程代码大小+数据大小+栈空间大小， kb command 进程的命令 进程状态： R 进程正在执行中 S 睡眠状态 T 追踪或停止 Z 僵尸进程 W 进程没有固定的pages &lt; 高优先级进程 N 低优先级进程 查找特定状态的进程 ps -ef -o stat,ppid,pid,cmd |grep -e '^[STZ]' -- '-o'指自定义输出哪些信息，grep -e 指定字符串作为查找内容的样式 grep重定向 不使用系统的标准输入（键盘）、输出（显示器）、错误（显示器）端口，重新指定输入，输出，错误端口，一般指向文件。通过重定向符实现重定向 &gt; 覆盖输出 / &gt;&gt; 末尾追加输出 &lt; 不常用 2&gt; / 2&gt;&gt; 错误重定向， &gt; 覆盖输出 &gt;&gt; 末尾追加输出 &amp;&gt; 输出重定向，错误重定向 管道命令 管道的含义， 命令接受标准输入后，产生标准输出，作为下一个命令的输入，依次类推，通过 | 衔接，形成类似管道线，单向执行，顺序为从左到右依次执行 find '' | grep | less/more ... 命令组合 使用元字符将若干shell命令组合 cmd1 ; cmd2 顺序执行cmd1，cmd2 cmd1&amp;&amp;cmd2 与逻辑，当cmd1成功执行，则执行cmd2，否则不执行cmd2； cmd1 || cmd2 或逻辑，当cmd1不成功执行时，则执行cmd2，否则不执行cmd2； 创建用户 linux是多用户的 用户账户： 普通用户 uid从500开始、 root用户 uid为0 组账户： 私有组 创建时未指定的默认是私有组 、 标准组 创建时需指定 主要是4个账户系统文件： /etc/passwd 用户 /etc/shadow 口令 /etc/group 组 /etc/gshadow 组口令 useradd user1 --创建 passwd user1 --认证 userdel -r user1 --删除用户及其目录 groupadd staff --创建staff组 useradd -G staff user1 --新建user1，属于staff组成员 usermod -G staff tom --将tom添加到staff组中 groupmod -n newstaff staff --修改组名 groupdel staff --删除组staff 用户密码时效： 修改/etc/login.defs 或者通过chage命令修改 【chage，不是change】 -l 【用户】查看 操作权限 r w x rwx 针对的用户 user （uid）、 group (gid)、 other 如果用户uid与文件uid相同，则应用用户权限 如果用户gid与文件gid相同，则应用用户组权限 如果uid，gid都不匹配，则应用其他用户权限 》》 文字设定法 chmod [augo][+-=][rwxugo(此处ugo指与对应用户权限相同)] 文件/目录 》》 数字设定法 chmod [0-7][0-7][0-7] 文件 chown 修改文件或目录的属主、属组 chown -R user:group 文件/目录 修改属主、属组 系统日常维护软件包及命令 htop包： 动态显示系统进程任务 procps包： nload包 iotop包 sysstat包 top 动态显示当前正运行的进程 tasks（运行中、睡眠、中止、僵尸进程）及其重要信息，包括内存和cpu占用 top 标准输出包括两部分： 统计信息、进程信息 统计信息： 第一行 top - 之后显示的是uptime的输出，依次为： 当前时间、系统运行时间、登录用户数、平均负载（依次为1，5，15min） 第二行 进程数统计及其状态 第三行 内存和交换分区信息 进程信息： pid 进程号 user 所有者 pr 优先级，越小优先级越高 ni 进程nice值，负值代表高优先级 正值代表低优先级 virt 进程占用虚拟内存 kb swap + res res 进程使用，且未被唤出的物理内存大小 kb code+data shr 共享内存 kb s 进程状态 d 不可中断的睡眠状态 r 运行 s 睡眠 t 跟踪/停止 z 僵尸进程 %cpu %mem 物理内存占比 time+command uptime 显示系统平均负载 vmstat 显示进程队列、内存、交换分区、块设备io以及cpu活跃信息 r 运行队列中等待运行的进程数 b 等待 i/o的进程数 swpd 交换空间 free 空闲的物理内存 buff 缓冲内存 cache 缓存的内存 inact 不活跃内存 active 活跃内存 si 每秒从交换区写到内存的大小 so 每秒写到交换区的内存大小 bi 每秒读取块设备的块数 bo 每秒写入块设备的快数 in 每秒中断数 cs 每秒的上下文切换次数 us 用户进程执行时间的百分比 sy 系统进程执行时间百分比 id 空闲时间百分比 wa 等待i/o时间的百分比 st 管理程序为另一个虚拟进程提供服务而等待虚拟cpu的百分比 分析系统状态的一些标准 **cpu**：平均负载，n个cpu，若平均负载小于n，则cpu空闲，反之繁忙 核心态和用户态进程执行时间占比&lt;70%，则视为状态良好，若&gt; 90%，表示cpu资源吃紧 若id&lt; 10% ，表示cpu性能较低，需要改善 数据备份 备份方式： 全量备份、增量备份、差分备份 备份周期： 每月全量、每天增量、每周差分 注意点： 备份需要定期验证； 备份应当与源主机分离","link":"/2023/04/06/linux%E5%91%BD%E4%BB%A4/"},{"title":"oracle基础","text":"oracle的认证证书（oracle database management） OCA Oracle Certified Associate OCP Oracle Certified Professional OCM Oracle Certified Master oracle官方入门教程的sql学习路径 1. retrieving data using the sql select statement 2. restricting and sorting data 3. using single-row functions to customize output 4. using Conversion functions and conditional expressions 5. reporting aggregated data using the group functions 6. display data from multiple tables using joins 7. using subqueries to solve queries 8. using set operators 9. managing tables using DML statements 10. introduction to data definition language 11. introduction to data dictionary views 12. creating sequences,synonyms and indexes 13. creating view 14. managing schema objects 15.retrieve data by using subqueries 16. manipulating data by using subqueries 17. controlling user access 18. manipulating data using advanced queries 19. managing data in different time zones oracle数据库管理与维护 1. 系统权限与实体权限 系统权限： 规定用户对数据库的使用权限 实体权限： 规定用户对数据库对象，如表、视图等的存取权限 1.1 账号创建、删除与授权（系统权限） create user username identified by pwd； // username，pwd 分别为要创建的用户及登录密码； grant connect,resource,dba to username; //授予数据库对象访问对象、创建数据库实体、创建数据库结构 drop user usename cascade // 删除用户及所有由用户创建的的对象； 1.2 查看用户权限（系统权限） select * from dba_role_privs; select * from dba_sys_privs; select * from role_sys_privs; 1.3 权限传递（系统权限） grant connect/resource/dba to username with admin option //可以传递所获得的权限； 补充： 若A授予B权限，则B可以将拥有的权限授予C； 如果B的权限被收回，B授予C的权限不会被收回，但A可以越过B收回C的权限； 1.4 权限回收（系统权限） revoke connect/resource/dba from username; 1.5 select/update/insert/delete/alter/index/execute/regerences 具体操作与系统权限几乎没有差异，唯一不同就是权限的回收是级联的。 1.6 情景模拟： 创建一个用户，允许传递权限，授予connect/resource/dba权限； create user con1 identified by &quot;123456&quot;; grant connect to con1 with admin option; show user; conn con1/123456; show user; 1.7 触发的报错： ORA-01045: user CON1 lacks CREATE SESSION privilege; logon denied； ORA-01919: role 'RESOUCE' does not exist ORA-01924: role 'CONCECT' not granted or does not exist ORA-01031: insufficient privileges 1.8 用户profile管理 profiles文件是口令和资源限制的配置集合，查看DBA_PROFILES表以了解详细信息； 主要包括： kernal type指resource_parameter； password type指password_parameter COMPOSITE_LIMIT --单个会话中，总资源消耗 默认unlimited SESSIONS_PER_USER --限制用户的并发会话数目 默认unlimited CPU_PER_SESSION --会话的cpu时间限制，单位为1/100秒 默认unlimited CPU_PER_CALL --依次调用/解析/执行/提取的cpu时间限制，单位为1/100秒，默认unlimited LOGICAL_READS_PER_SESSION --指定一个个会话允许读的数据块的数目，包括从内存和磁盘读取的数据块，默认unlimited LOGICAL_READS_PER_CALL --指定依次sql解析、执行、提取所允许读的最大数据块数目，默认unlimited IDLE_TIME --指定会话超时时间，单位为分钟，默认unlimited CONNECT_TIME --指定会话的总的连接时间，单位为分钟，默认unlimited PRIVATE_SGA --指定一个会话可以在共享池中分配到的空间大小，单位为byte，默认unlimited FAILED_LOGIN_ATTEMPTS --允许登录失败次数 PASSWORD_LIFE_TIME --密码允许使用天数 PASSWORD_REUSE_TIME --相同的密码，修改后多少天才能重新使用 PASSWORD_REUSE_MAX --相同的密码，修改多少次后才能重新使用 PASSWORD_VERIFY_FUNCTION --密码验证 ，默认null PASSWORD_LOCK_TIME --账号锁定时间 ，默认1天 PASSWORD_GRACE_TIME --从通知改密码到密码强制修改可宽限的时间 INACTIVE_ACCOUNT_TIME --一定时间内不使用账号就锁定 1.9 管理用户profile 新建： create profile profile_name limit limit_param limit_value ... 修改： alter profile profile_name limit limit_param limit_value ... 删除： drop profile profile_name; 1.10 数据库实例管理 oracle简介ORACLE数据库系统是美国ORACLE公司（甲骨文）提供的以分布式数据库为核心的一组软件产品，是目前最流行的客户 / 服务器（client / server 或 B / S）体系结构的数据库之一。迄今为止ORACLE数据库是世界上使用最广泛的数据库管理系统。 oracle的特点 支持多用户、大事务量的事务处理 数据安全性和完整性控制（银行金融等行业比较看重这一点） 支持分布式数据处理 可移植性 oracle是行存数据库， 行存数据库的dml效率较高（将一行数据放在一个存储单元，当对数据修改时，只要找到所在行就能一次性更改，相应的，因为每次都要读一整行，所以当进行查询时，即使指定列，还是会遍历一整行数据）， 列存数据库的查询效率高（将一列数据放在一个存储单元，当对指定列进行查询时，只需要访问一次）。 行存，即数据逐行存储到磁盘，列存，即数据逐列存储到磁盘。 oracle 体系结构 database结构 -- | 物理结构： 数据文件 *.dbf: 实际存储数据的文件 日志文件 *.log 控制文件 *.ctl 参数文件 InitSID.ora 逻辑结构： 表空间 tablespace： 数据库的最大逻辑存储结构，和数据文件对应，一个表空间可以有多个数据文件，但一个数据文件只能属于一个表空间。 段 segment 区 extent 块 block instance结构 -- | 内存结构：sga，包括share pool、db buffer cache、redo log buffer、large pool、java pool。pga程序跑起来时分配，服务于server process，存放服务器进程的数据和控制信息，独立于sga的内存区域。 进程结构：user process、server process 用户连接时即创建，background process：... 数据库相关概念 启动oracle前提应先启动instance. Instance=SGA+background process实例=内存分配+一组后台进程 关于实例、表空间、schema 实例，也即instance，创建数据库时，指定的数据库名就是instance，也叫做sid。 表空间，是个逻辑概念，数据库下设N个表空间，表空间由数据文件支撑，虚拟的表空间，实体的数据文件。 schema，即用户拥有的对象集合，用户在创建时，要指定default tablespaces；如果不指定，则默认属于USERS表空间。schema的含义就是，用户在所属的表空间下，持有的数据库对象资源。 重要的表及其用途 1. SELECT * FROM NLS_DATABASE_PARAMETERS ; //oracle的nls（national language support）配置，parameter and value； --设置 NLS_LANG 环境参数是为 Oracle 软件指定语言环境行为的一种简便的方法。利用此方法可以设置客户端应用和数据库服务器使用的语言和区域。还可以指示客户端的字符集，该字符集与客户端程序输入或显示的数据的字符集相对应 --NLL 有3个组成要素： 语言（默认american）、地区以及字符集 --查看本地是否配置了NLS_LANG环境变量： sqlplus查询 host echo %NLS_LANG% //返回具体的字符集，则配置了环境变量； 或者 查看注册表 @.[%NLS_LANG%] //unable to open file .[xxx] ，表示注册表未设置； 包含下列信息： NLS_RDBMS_VERSION --db版本 NLS_NCHAR_CONV_EXCP -- NLS_LENGTH_SEMANTICS NLS_COMP NLS_DUAL_CURRENCY NLS_TIMESTAMP_TZ_FORMAT NLS_TIME_TZ_FORMAT NLS_TIMESTAMP_FORMAT NLS_TIME_FORMAT NLS_SORT NLS_DATE_LANGUAGE NLS_DATE_FORMAT NLS_CALENDAR NLS_NUMERIC_CHARACTERS NLS_NCHAR_CHARACTERSET NLS_CHARACTERSET NLS_ISO_CURRENCY NLS_CURRENCY NLS_TERRITORY NLS_LANGUAGE 2. SELECT * FROM nls_session_parameters; 3. SELECT * FROM NLS_INSTANCE_PARAMETERS ; 4. 数据字典： 有3类， 分别是——DBA_*、ALL_*、USER_* 4.1 select * from dba_all_tables; --查看当前数据库下的所有表对象 select * from user_all_tables; --查看属于当前user的所有表对象 sql基础 //关键字、表名和字段名都不区分大小写 =============================================既是操作数据，那必然先从数据类型开始 1. 字符串： char 、varchar、varchar2、nvarchar、nvarchar2 2. 数字： number（l,a）,遵循四舍五入,比较规则：A larger value is considered greater than a smaller one. All negative numbers are less than zero and all positive numbers. Thus, -1 is less than 100; -100 is less than -1. The floating-point value NaN (not a number) is greater than any other numeric value and is equal to itself. 测试： select (binary_float/0) from dual; --NaN 判断:is NAN 3. 日期： date 注意日期格式 yyyy-mm-dd hh24:mi:ss mi区别于mm月份 4. clob和blob： 都属于lob，存储大字段类型， blob-binary large object 二进制大型对象，存储二进制字节流数据，如程序、图像、影音等 character large object 字符型大型对象，存储文本型数据，如xml，json A binary value of the data type RAW or BLOB is a sequence of bytes. When two binary values are compared, the corresponding, consecutive bytes of the two byte sequences are compared in turn. If the first bytes of both compared values are different, the binary value that contains the byte with the lower numeric value is considered smaller. If the first bytes are equal, second bytes are compared analogously, and so on, until either the compared bytes differ or the comparison process reaches the end of one of the values. In the latter case, the value that is shorter is considered smaller. Binary values of the data type BLOB cannot be compared directly in comparison conditions. However, they can be compared with the PL/SQL function DBMS_LOB.COMPARE. =============================================sql 标准结构 标准sql结构及执行顺序 select [TOP|DISTINCT] [选择列表]|[*] from 数据源 [where 查询条件] [group by 分组条件] [having 过滤条件] [order by 排序条件 asc|desc nulls first|last]; 查看执行计划： explain plan FOR SELECT * FROM DEMO o; //step 1 SELECT * FROM table(DBMS_XPLAN.display()); //step2 =============================================sql 执行顺序 （5）select [（5-3）TOP|（5-2）DISTINCT] （5-1）[选择列表]|[*] （1）from 数据源 （2）[where 查询条件] （3）[group by 分组条件] （4）[having 过滤条件] （6）[order by asc|desc nulls first|last]; =============================================操作类型细分 1.DDL（DataDefinitionLanguage）：数据定义语言，用来定义数据库对象：库、表、列等； --drop、create、alter 2.DML（DataManipulationLanguage）：数据操作语言，用来定义数据库记录（数据）； --insert 、update 、delete 3.DQL（DataQueryLanguage）：数据查询语言，用来查询记录（数据）； --select *** from *** where *** 4.DCL（DataControlLanguage）：数据控制语言，用来定义访问权限和安全级别。--显式提交、隐式提交 控制方法：set autocommit on/off; --grant、rollback、commit =============================================条件判断、循环 =============================================对象：表、视图、序列、函数和存储过程、游标、触发器、索引、同义词 1. 表： 行*列 分区表 索引组织表 堆标: 默认数据表存储结构 创建方式： create table tablename（ col type， ... ） 2. 视图：基于表或者视图，提取或派生出数据 创建方式： create or replace view as [select ...] 3. 序列：生成唯一整数值的结构，不建议使用，因为序列存储在内存中，内存刷新 序列： create sequence seq_auto_add start with 1 --起始编号 nomaxvalue --不设置最大值上限，默认 10^28-1 nominvalue --不设置最小值下限，默认 -(10^27-1) increment by 1 --设置增长步长, 负数表示递减 cache 20; --默认缓存是20，第一次新增，则直接在缓存中写入20个数字，下一次新增直接获取缓存的数字；当缓存被刷新时，cache失效，所以不能保证自增序列的连续性。 --cache要满足表达式： select seq_auto_add.nextval from dual; CREATE TABLE ADD_TEST ( ID INT, NAME VARCHAR2(16) ) --插入序列的方式有多种 --第一种逐条插入 insert into table() values (seq_auto_add.nextval) --第二种触发器插入 create or replace trigger tri_tablename before insert on ADD_TEST for each row begin select ADD_TEST.ID into :new.seq_auto_add from dual; end; 4. 索引: 为经常作为查询条件的列，创建索引，可以显著提高查询效率，但使用索引会降低update、delete、insert效率。 oracle中，会自动为主键和唯一约束的列创建索引。 create index on tablename(col1,col2...coln) 5. 函数： 内嵌函数： * decode(exp，condition，result，default)，如果exp=condition,返回result，否则返回default，默认是null。 * coalesce（exp1,exp2,...,expn）,如果第一个值非空，那么返回，否则依次比较，直至找到一个非空的值，若所有表达式均为空，则返回null. * nvl（exp,replace_with）,如果exp为空，则用replace_with替代. * nvl2(exp,exp2,exp3),如果exp为null，返回exp3，否则返回exp2. * substr（str,a,b）,从str中截取从第a个字符串起，长度为b的字符串。如果a是负数，则|a|&gt;=b时，从a位置起，向后截取长度为b的字符串，否则，向后截取长度为|a|的字符串 * instr（str1，str2，b），返回str1中，str2第b次出现时的位置，b可以是负数。 * add() * minus() * SELECT LOWER('TR') FROM dual; --小写 * SELECT UPPER('TR') FROM dual; --大写 * round（） * sum（） * avg（） 自定义函数 规范： 带参数的存储过程： CREATE OR REPLACE PROCEDURE 存储过程名字( --输入参数 IN NUMBER, --输出参数 OUT NUMBER --可以有多个输入参数和输出参数 ) IS --这个区间可以用来定义变量和创建游标 BEGIN --执行游标或者执行语句 commit; --对上面的内容进行提交 exception//存储过程异常 when others then --异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定 /* 预定义异常： DUP_VAL_ON_INDEX、INVALID_CURSOR、INVALID_NUMBER、SELECT INTO【NO_DATA_FOUND、TOO_MANY_ROWS】、ZERO_DIVIDE、CURSOR_ALREADY_OPEN 自定义异常： RAISE_APPLICATION_ERROR(异常码-20000~ -20999，异常信息) exp_name EXCEPTION，声明； raise exp_name， 引发异常 */ rollback; dbms_output.put_line(sqlcode); dbms_output.put_line(substr(sqlerrm, 1, 512)); END 存储过程名字; 注意：其中参数IN表示输入参数，是参数的默认模式。 OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。 OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程 IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。 6.游标 Cursor is select … Open cursor Fetch cursor into 变量 Close cursor 游标的属性 FOUND/NOTFOUND/ISOPEN/ROWCOUNT 7.触发器 —— insert、update、delete操作执行在特定表上时，自动执行预定义的语句序列。 create or replace trigger tri_test before/after insert/update/delete on [object] for each row --默认是语句级触发,如果用了行级触发，那么要用old，new [follows] ==多个触发器时，执行先后顺序在此标注,不建议使用 when old 旧值/ new 新值 --此处old，new 不带 : begin 代码块; if deleting/updating/deleting then end if; --此处的引用old和new 需要带 : ，修改方式为 referencing new as alisa1 old as alias2； end; 索引索引相当于数据的目录，在oracle中，rowid是每一行数据的标识，当数据量膨胀时，rowid也会随之膨胀，建立索引，能够快速找到rowid 索引建立时，会对指定列的数据做排序，并将排序后的值与rowid绑定保存 索引建立在作为条件、排序的列上；多表关联键上；小表不建索引； 索引占用物理空间，索引，不要随意建索引 drop truncate deletedrop truncate 是 DDL， delete是dml执行效率上， drop &gt; truncate&gt;delete delete执行不会自动提交，可以回滚； drop与truncate自动提交，不可回滚 delete、truncate是对数据的删除，保留结构定义； drop是对结构和数据的删除，且被表依赖的对象被删除，或者失效 动态性能视图 什么是动态性能视图？ 动态性能视图是表（v_$fixed_table中，每个object的type都是table），通过它将内存中的数据或者控制文件里的数据以表的形式展现出来，只要数据库在运行，就不断的更新动态性能视图； 动态视图的标记 动态视图的标记主要有5种：V$ 针对单个实例的视图、GV$ 全局视图针对多个实例环境、X$、GO$、O$ 2个重要的动态性能视图 v_$fixed_table --罗列全部的动态性能视图 v_$fixed_view_definition --罗列动态性能视图的定义，具体为一串sql 关于动态性能视图的一些说明 1. 需要sysdba权限才能对动态性能视图进行访问 2. 动态性能视图只能查看，不能做修改 3. 动态性能视图随着数据库实例的启停创建、删除 4. 动态性能视图是描述数据的数据，它的信息主要来自内存和控制文件 5. 数据库实例的nomount、mount以及open阶段中，只有open状态是可以访问v_$fixed_table, nonmount状态下，可以查看内存信息相关的动态性能视图 mount状态下，进一步读取到控制文件，可以查看相关的动态性能视图 open状态下，进一步访问与oracle性能相关的动态性能视图 一些有用的动态性能视图 1. v$instance 当前实例的描述信息，如版本，主机，实例名，启动状态， 2. v$sga &amp; v$sgainfo（更详细） sga的组成， 包含3部分， 单位均为**byte** a&gt; fixed size sga的固定大小，包含数据库和实例的状态信息等通用信息，后台进程需要访问这部分信息，不存储用户数据 b&gt; variable size 包括shared_pool_size、java_pool_size和large_pool_size c&gt; database buffer db_cache_size的大小 d&gt; redo buffer 代表日志缓冲区的大小 3. V$parameter 初始化参数信息 4. v$version 查看版本信息 5. v$session 会话信息，username为null的，指后台进程会话 6. v$process 进程信息，包含服务器进程和后台进程 7. v$controlfile、v$datafile、v$dbfile、v$logfile、v$log 8. v$thread -- 9. v$lock --显示锁信息，与v$session关联使用 10. v$locked_object --显示被加锁的数据库对象，通过与dba_objects进行连接，显示具体的对象名及执行加锁操作的oracle用户名 11. v$tablespace --显示表空间信息 12. v$sql &amp; v$sqltext &amp; v$sqlarea --查看执行的脚本信息 13. v$sysstat --系统的统计信息 重要且直观 14. v$system_event --数据库当前的活动信息，如磁盘读写，控制文件的状态 data dump工具 expdp/impdp exp/imp rman","link":"/2023/04/02/oracle%E5%9F%BA%E7%A1%80/"},{"title":"docker","text":"Docker采用客户端/服务器端架构, 使用远程API来管理和创建容器, 可以轻松的创建一个轻量级的, 可移植的容器.，它是一种容器技术。 容器： 容器是镜像的运行实体，是主机上运行的进程。 镜像： 镜像是一系列的只读文件，包含了容器运行时所有的基础文件和配置信息 ，是运行容器的基础。 仓库： 存放镜像文件的存储单元 相较于虚拟机，docker的交付速度更快，资源消耗更低，基本没有性能损耗。 传统虚拟机是虚拟出一个主机硬件, 并且运行一个完整的操作系统, 然后在这个系统上安装和运行软件,在物理机上，运行的虚拟机的数量很有限。 容器内的应用直接运行在宿主机的内核之上, 容器并没有自己的内核, 也不需要虚拟硬件, 相当轻量化，相较于虚拟机，容器可以运行几百个。 每个容器间是相互隔离, 每个容器内都要一个属于自己的独立文件系统, 独立的进程空间, 网络空间, 用户空间等, 所以在同一个宿主机上的多个容器之间彼此不会相互影响 Docker的三大理念就是build, ship, run. 一次构建，处处使用 build： 构造镜像 save ship： 运输镜像 pull push run： 运行镜像 run Docker通过namespace（防止进程资源抢占）和control group（硬件资源隔离，实现共享资源而不会相互影响）来提供容器的资源隔离与安全保障等, 所以Docker容器在运行时, 不需要类似虚拟机的额外资源开销, 因此可以大幅度提供资源利用率。 docker结构 client：通过client与daemon建立通信 daemon： daemon是系统进程，运行docker即运行daemon， 1. 用于接收并处理client发起的请求， 2. 管理所有的docker容器。 daemon的组成： server、engine and Job。 server接收请求后，通过路由寻找handler，并分发给对应handler处理请求 engine是docker的核心模块，存储容器信息，管理docker大部分job的执行 job是gengine内部的基本工作执行单元，如运行、创建、下载等动作 registry： 存储容器镜像的仓库。容器镜像是容器创建时用来初始化容器的文件系统内容。 与registry通信一般有3种动作， search 搜索、pull 下载 、push 上传 安装 dockerDocker支持64位版本的CentOS 7和CentOS 8及更高版本，它要求Linux内核版本不低于3.10。 1. 卸载旧的版本 (重新安装需要这一步) yum remove docker *** /// ***指docker相关的目录全部删掉 2. 配置仓库 先下载软件包： yum install -y yum-utils 国内的仓库： yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3. 安装 yum install -y docker-ce 下载过程中报错，会有建议执行命令，照着敲就好了。 4.启动docker systemctl start docker 或 service docker start 5.常见的Docker操作命令： 搜索仓库镜像：docker search --filter=stars=1000 镜像名 拉取镜像：docker pull 镜像名:tag 下载的镜像存放在 /var/lib/docker/image下 查看正在运行的容器：docker ps 查看所有容器：docker ps -a 删除容器：docker rm container_id 查看镜像：docker images 删除镜像：docker rmi image_id 启动（停止的）容器：docker start 容器ID 停止容器：docker stop 容器ID 重启容器：docker restart 容器ID 通过docker help命令来查看。 以tomcat为例使用docker部署并运行tomcat //docker的默认目录为/var/lib/docker //镜像下载目录为 /docker/image/overlay2 1. docker search tomcat: 版本信息 2. docker pull 下载查询出的tomcat-name镜像 3. docker images 查看镜像 4. docker run -d \\ --后台运行， -t为交互式运行 -p linux服务器端口：容器端口号 \\ --内外映射 --name 给容器起名字 tomcat 5. 查看tomcat运行情况， curl 0.0.0.0：端口号 ，会返回一串前端的html页面信息 这里拿到了404，查看tomcat的webapps目录，发现没有静态资源。 执行： docker exec -it container_id /bin/bash 进入容器内部 执行： ls 查看容器目录下的文件夹 执行： ls webapps 查看静态资源 添加静态资源，查看到webapps.dist下有静态资源 切到tomcat目录下， cp ./webapps.dist/* ./webapps 将资源复制 exit 退出容器目录 重新curl 6. 查看容器运行状态： docker ps （-a） 7. 关闭容器： docker stop container_id 8. 删除容器： docker rm container_id --可以用正则表达式或者管道函数，批量删除或者关闭容器 9. 镜像打包： docker save 镜像名：版本号 &gt; 名称.tar 10.镜像加载: docker load &lt; 镜像名.tar 容器资源分配问题 创建容器时，可能要考虑内存泄漏，out-of-memory，因此 使用-m参数来设置分配内存大小 docker配置私有仓库 （linux中 shift+page up | page down 实现上下滑动检索） docker pull registry --docker官方提供的搭建私有仓库的镜像","link":"/2023/04/20/docker/"},{"title":"springboot","text":"1. 什么是springboot，与 hibernate、struts并列java主流框架 springboot是由pivotal团队在spring基础上推出的开源框架，为了简化spring应用的搭建和开发过程 1.1 springboot的特点： 1. Create stand-alone Spring applications 2. Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 3. Provide opinionated 'starter' dependencies to simplify your build configuration 4. Automatically configure Spring and 3rd party libraries whenever possible 5. Provide production-ready features such as metrics, health checks, and externalized configuration 6. Absolutely no code generation and no requirement for XML configuration 1.2 springboot的依赖管理 场景启动器： 命名如： springboot-starter-xxx 1. 依赖传递 A 依赖B，B依赖C， 则A同时拥有B和C，场景启动器会自动把这个场景需要的核心依赖全部导入 2. 依赖的版本管理 每个boot项目都有parent项目 parent项目的父项目是spring-boot-dependncis spring-boot-dependncies会把所有的依赖版本都声明好 如果需要修改版本， 可以自行通过properties声明 或者 可以直接在dependencies导入配置中修改版本 1.3 springboot的自动配置机制 1. 自动配置tomcat、springmvc 容器中有了什么组件，就有什么功能 2. 默认的包扫描规则 springboot只会扫描主程序所在的包及其下面的子包 或者 可以自定义扫描路径，解决与主程序不在同级包下导致的功能无法正常访问问题 scanBasePackage = “” @componentScan（“”） 3. 默认配置值 如端口默认是8080 配置项是和某个类的对象值进行一一绑定的 4. 按需加载配置 导入什么场景，则配置哪些场景所需要的包 2. 搭建一个简单的应用下载spring boot extension pack，鄙人用的vscode,所以就直接无脑上插件。按照spring initializer java support插件的指导，执行命令，生成springboot项目模板这里是执行的命令 1. ctrl+shift+P 进入全局搜索 2. spring initializer 创建项目 下载jdk，配置环境变量 1. oracle.com resource-》developer download -》 java -》 java jdk for developer 2. 下载安装包，一路next 3. 配置环境变量 3.1 new 系统变量 name： java_home variable: 下载目录 3.2 path 新建路径： %java_home%\\bin 3.3 测试配置是否正确， cmd java -version，输出版本即配置完成 3. springboot的框架结构 1. 配置文件，文件名是固定的，在springboot启动时自动读取，修改spring boot自动配置的默认值 application.property application.yml 补充说明，常见的配置文件格式有： json、xml、yaml ** YAML 全称 YAML Ain't Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件 yaml的语法： 1. 大小写敏感 2. 缩进表示层级关系 3. 同级元素必须左对齐 yaml的书写格式： 1. 字面量 name: [空格]proprty 2. 对象 写法一： name: name: xxx url: xxx 写法二： name: {name: xxx,url:xxx} 3. 数组 写法一： name: -dog -cat -monkey 写法二： name: {dog,cat,monkey} yaml的分行符： --- 一个yaml文件可以由一个或多个文档组成，文档之间用---作为分隔符，各文档相互独立，互不干扰。 2. src **主程序** including： java文件 其中 Application.java 有声明@SpringBootApplication的java文件是程序的入口 3. resource **静态资源static、页面 templates** including： static放访问的静态资源 templates放页面模板 application.properties 4. servlet 容器 springboot支持 tomcat、jetty以及undertow demo编写过程中遇到的问题 1. build引入依赖过程中，存在依赖冲突，导致不能运行项目， 报错为：failed to determine a suitable driver class 2. 在修改配置文件的路径时，因 / 和 \\ 问题报错 报错为：invalid escape character in string 解决办法： /改为 \\ 或者 // 3. 注解无法引入 报错： xx cannot be resovled 原因：没有在pom中引入依赖，配置dependency后rebuild pom即可 4. controller与启动类目录关系 报错： whitelabel error page 现象： web服务器界面不能正常响应 原因： controller要与启动类在同级目录下，否则无法正常读取 5. pom修改后，引入依赖特别慢，查看了相关资料，与国外网址有关，要修改下载地址 存疑： vscode怎么修改maven的setting.xml","link":"/2023/07/12/springboot/"},{"title":"tomcat","text":"系统学习web服务器 什么是web服务器web服务器，又称http服务器，因为它使用http协议与客户端通信。 补充： 基于java的web服务器，使用2个重要的类，java.net.Socket 和 java.net.ServerSocket http协议是请求-应答作业模式，客户端发起请求，服务端响应请求。 http协议使用tcp连接，默认使用80端口。 http的第一个版本是http/0.9，后被1.0取代，目前1.0和1.1是广泛应用的版本。 tomcat，catalinatomcat： 基于java开发的，部署web项目的容器，它是web服务器和servlet容器的结合体， 具备web服务器的功能 —— 将服务主机上的资源映射为一个url供外界访问 也具备serlet容器的功能 —— 处理客户端的http request，处理，并返回response，实现客户端与服务端的动态数据交互 servlet的架构： web browser —— http &gt; web server | servlet program | database servlet的模块组成： catalina(servlet容器) coyote（连接器） 为catalina提供连接通信 jasper（jsp引擎） 为catalina提供jsp引擎 javael（表达式语言） naming（命名服务） 为catalina提供jndi服务 juli（服务器日志） 为catalina提供日志服务 catalina： catalina是tomcat web服务器的核心组件之一，它是servlet容器，负责处理http请求，管理servlet声明周期，提供会话管理和安全性支持等功能 catalina的结构： services： connector 处理与客户端的通信，接收请求，转给对应的容器处理，并将处理结构返回给客户 containner 处理servlet请求 engine 父容器 一个service只能有一个engine host 子容器（父容器） 虚拟主机，一个engine可以包含多个host context 子容器（父容器） web应用程序，一个host下可以包含多个context wrapper 子容器 表示一个servlet，它是容器的最底层，没有子容器。 一个context可以包含多个wrapper tomcat 启动日志报错1. 找不到基于APR的Apache Tomcat本机库,该库允许在生产环境中获得最佳性能 需要下载tcnative-1.dll，放到jdk的bin目录下 下载地址： https://tomcat.apache.org/download-native.cgi 2. 基于APR的本地库加载失败.错误报告为[C:\\Program Files\\Java\\jdk-17\\bin\\tcnative-1.dll: Can't load IA 32-bit .dll on a AMD 64-bit platform] 下载的dll是 win32， jdk是win64 留意native1和native2的区别 3. The server cannot be started because one or more of the ports are invalid. 在eclipse打开tomcat时，报错，双击server区域列出的server，看ports区域是否有未指定的端口， 如 tomcat admin port默认是 -，要自己修改。 4. jdk与tomcat的冲突检测 官网网址如下： https://tomcat.apache.org/whichversion.html 5. eclipse tomcat启动成功，但localhost无法访问资源 解决办法： 勾选tomcat server的server locations下 use tomcat installation 说明： 在本地访问webapp下的资源时，路径读取的是server.xml中， Host appBase='webapps'这段， 如果在webapp下新建一个目录WEB_DEMO，放一个index.html， 则地址可以写为： http://localhost:8080/WEB_DEMO/INDEX.HTML 端口读取的是server.xml中 Connector的配置， &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; maxParameterCount=&quot;1000&quot; /&gt;","link":"/2023/09/24/tomcat/"},{"title":"初窥mysql","text":"参考手册 https://dev.mysql.com/doc/refman/8.0/en/database-use.html 以下英语内容取自官方文档，请读者自行理解 下载地址 community版本 https://dev.mysql.com/downloads/ 练手用，所以选择了server only，之后用dbeaver连接,记得配一下环境变量command line 下的使用 连接 ： mysql -h localhost -u root -p // -h mysql server地址，-u 用户 ， -p 端口 默认3306 查看db： show databases; by default 1.information_schema,2.mysql,3.performance_schema,4.sys 使用db： use db_name; 如果有，则database changed，否则 1049（42000） unknown database 'db_name' 查看tables： show tables; mysql 入门1 基本数据类型 literal values 1.1 string： A string is a sequence of bytes or characters, enclosed within either single quote (') or double quote (&quot;) characters // 单引号或双引号括起来的一组字母 1.2 numeric：Number literals include exact-value (integer and DECIMAL) literals and approximate-value (floating-point) literals. // 整型、浮点型 1.3 date and time：Date and time values can be represented in several formats, such as quoted strings or as numbers, depending on the exact type of the value and other factors. For example, in contexts where MySQL expects a date, it interprets any of '2015-07-21', '20150721', and 20150721 as a date. //时间或日期类型对格式要求不高，但需要是有效的年月日，年份前2位可以省略。 //月份、日期及时间必须是有效的，否则会视作&quot;0000-00-00 00：00：00&quot; . //yyyy-mm-ddThh24:hh:ss 用大写的T 而不是空格来分割年份与时间 //不按规范书写会报warning或者导致错误 Dates containing two-digit year values are ambiguous because the century is unknown. MySQL interprets two-digit year values using these rules: Year values in the range 70-99 become 1970-1999. Year values in the range 00-69 become 2000-2069. 1.4 hexadecimal：Hexadecimal literal values are written using X'val' or 0xval notation, where val contains hexadecimal digits (0..9, A..F). Lettercase of the digits and of any leading X does not matter. A leading 0x is case-sensitive and cannot be written as 0X. 1.5 bit-value：Bit-value literals are written using b'val' or 0bval notation. val is a binary value written using zeros and ones. Lettercase of any leading b does not matter. A leading 0b is case-sensitive and cannot be written as 0B. 1.6 boolean：The constants TRUE and FALSE evaluate to 1 and 0, respectively. The constant names can be written in any lettercase. 1.7 null：The NULL value means “no data.” NULL can be written in any lettercase. dbeaver连接mysql出现的问题 问题1： public key retrieval is not allowed 解决办法： 编辑连接》驱动属性》 allowpublicretrieval 设置为true 问题2： Access denied for user 解决办法： use mysql； select host,user from user; 更改root的host为% ，意为任意IP可以root权限访问。 2 sql语法 select from where group by having order by limit 2.1 Data Definition Statements ——————————————————create、alter、drop warning: Atomic DDL is not transactional DDL. DDL statements, atomic or otherwise, implicitly end any transaction that is active in the current session, as if you had done a COMMIT before executing the statement. This means that DDL statements cannot be performed within another transaction, within transaction control statements such as START TRANSACTION ... COMMIT, or combined with other statements within the same transaction. The atomic DDL feature supports both table and non-table DDL statements. Table-related DDL operations require storage engine support, whereas non-table DDL operations do not. Currently, only the InnoDB storage engine supports atomic DDL. **Supported table DDL statements** include CREATE, ALTER, and DROP statements for databases, tablespaces, tables, and indexes, and the TRUNCATE TABLE statement. **S**upported non-table DDL statements** include: CREATE and DROP statements, and, if applicable, ALTER statements for stored programs, triggers, views, and loadable functions. Account management statements: CREATE, ALTER, DROP, and, if applicable, RENAME statements for users and roles, as well as GRANT and REVOKE statements. 2.2 Data Manipulation Statements ——————————————call、delete、do、except、handler、import、insert、intersect、replace、select、update 2.2.1 The CALL statement invokes a stored procedure that was defined previously with CREATE PROCEDURE. //调用预定义的存储过程 2.3 Transactional and Locking Statements 2.4 Replication Statements 2.5 Prepared Statements 2.6 Compound Statement Syntax 2.7 Database Administration Statements 2.8 Utility Statements","link":"/2023/06/29/%E5%88%9D%E7%AA%A5mysql/"},{"title":"sql server","text":"写在前面的话，因为工作中需要使用sql server，语句使用处处受阻，遂记录基础语法，常回顾 关键字create、alter、insert、update、delete、drop、truncate 对表操作1. 创建表/临时表 create table table_name ( col1 datatype constraints, col2 datatype constraints, ... col3 datatype constraints ) 如： CREATE TABLE dbo.PurchaseOrderDetail ( PurchaseOrderID INT NOT NULL, LineNumber SMALLINT NOT NULL, ProductID INT NULL, UnitPrice MONEY NULL, OrderQty SMALLINT NULL, ReceivedQty FLOAT NULL, RejectedQty FLOAT NULL, DueDate DATETIME NULL ); 2. 删除表2.1 限制和局限不能删除被 FOREIGN KEY 约束引用的表。 必须先删除引用 FOREIGN KEY 约束或引用表。 如果要在同一个 DROP TABLE 语句中删除引用表以及包含主键的表，则必须先列出引用表。 2.2 删除表时，表的规则或默认值将被解除绑定，与该表关联的任何约束或触发器将被自动删除。 如果要重新创建表，则必须重新绑定相应的规则和默认值，重新创建某些触发器，并添加所有必需的约束。 2.3 如果删除的表包含带有 FILESTREAM 属性的 varbinary (max) 列，则不会删除在文件系统中存储的任何数据。 2.4 不应在同一个批处理中对同一个表执行 DROP TABLE 和 CREATE TABLE。 否则，可能出现意外错误。 2.5 任何引用已删除表的视图或存储过程都必须显式删除或修改，以便删除对该表的引用。 DROP TABLE dbo.PurchaseOrderDetail; 3. 复制表3.1 需要具备create table 权限，才能复制表 --如果目标表已经存在，仅复制数据，使用如下sql insert into taget_table_name select ... from source_table_name USE AdventureWorks2022; GO CREATE TABLE dbo.EmployeeSales ( BusinessEntityID varchar(11) NOT NULL, SalesYTD money NOT NULL ); GO INSERT INTO dbo.EmployeeSales SELECT BusinessEntityID, SalesYTD FROM Sales.SalesPerson; GO --如果目标表不存在，复制表结构及数据，使用如下sql select ...into target_table_name from source_table_name SELECT...INTO 语句的操作分为两个部分：创建新表，然后插入行。 这意味着如果插入失败，它们将全部回滚，但新的（空）表将保留。 SELECT c.FirstName, c.LastName, e.JobTitle, a.AddressLine1, a.City, sp.Name AS [State/Province], a.PostalCode INTO dbo.EmployeeAddresses FROM Person.Person AS c JOIN HumanResources.Employee AS e ON e.BusinessEntityID = c.BusinessEntityID JOIN Person.BusinessEntityAddress AS bea ON e.BusinessEntityID = bea.BusinessEntityID JOIN Person.Address AS a ON bea.AddressID = a.AddressID JOIN Person.StateProvince as sp ON sp.StateProvinceID = a.StateProvinceID; GO 如果要复制的表来源为第三方数据库， USE master; GO -- Create a link to the remote data source. -- Specify a valid server name for @datasrc as 'server_name' -- or 'server_name\\instance_name'. EXEC sp_addlinkedserver @server = N'MyLinkServer', @srvproduct = N' ', @provider = N'SQLNCLI', @datasrc = N'server_name', @catalog = N'AdventureWorks2022'; GO USE AdventureWorks2022; GO -- Specify the remote data source in the FROM clause using a four-part name -- in the form linked_server.catalog.schema.object. SELECT DepartmentID, Name, GroupName, ModifiedDate INTO dbo.Departments FROM MyLinkServer.AdventureWorks2022.HumanResources.Department GO -- Use the OPENQUERY function to access the remote data source. SELECT DepartmentID, Name, GroupName, ModifiedDate INTO dbo.DepartmentsUsingOpenQuery FROM OPENQUERY(MyLinkServer, 'SELECT * FROM AdventureWorks2022.HumanResources.Department'); GO -- Use the OPENDATASOURCE function to specify the remote data source. -- Specify a valid server name for Data Source using the format -- server_name or server_name\\instance_name. SELECT DepartmentID, Name, GroupName, ModifiedDate INTO dbo.DepartmentsUsingOpenDataSource FROM OPENDATASOURCE('SQLNCLI', 'Data Source=server_name;Integrated Security=SSPI') .AdventureWorks2022.HumanResources.Department; GO 4. 重命名表4.1 需要具备alter权限，才能重命名 sp_rename '', --1. objectname 此处是表的列，写法为 table.column/schema.table.column 此处是索引，写法为 table.index/schema.table.index 此处是约束,写法为 schema.constraint '', --2. new_name 新名称 '' --3. object_type 可以是column、database、index、object、statistics、userdatatype USE AdventureWorks2022; GO schema = sales table = SalesTerritory new_name = SalesTerr EXEC sp_rename 'Sales.SalesTerritory', 'SalesTerr'; 5. 查看表定义EXEC sp_help 'dbo.mytable'; 6. 查看表的依赖关系7. 添加列ALTER TABLE dbo.doc_exa ADD column_b VARCHAR(20) NULL, column_c INT NULL ; 8. 删除列ALTER TABLE dbo.doc_exb DROP COLUMN column_b; 9. 对列重命名EXEC sp_rename 'dbo.ErrorLog.ErrorTime', 'ErrorDateTime', 'COLUMN'; 将errorlog表的errortime字段，重命名为errordatetime 10. 修改列的数据类型CREATE TABLE dbo.doc_exy (column_a INT ); GO INSERT INTO dbo.doc_exy (column_a) VALUES (10); GO ALTER TABLE dbo.doc_exy ALTER COLUMN column_a DECIMAL (5, 2); GO 11. 复制列USE AdventureWorks2022; GO CREATE TABLE dbo.EmployeeSales ( BusinessEntityID varchar(11) NOT NULL, SalesYTD money NOT NULL ); GO INSERT INTO dbo.EmployeeSales SELECT BusinessEntityID, SalesYTD FROM Sales.SalesPerson; 主键表通常具有包含唯一标识表中每一行的值的一列或一组列。 这样的一列或多列称为表的主键 (PK)，用于强制表的实体完整性。 外键 A是B的外键，则先有A，后有B，否则会报错Person 表的主键，被PersonSales表引用， 如PersonSales.personID=Person.ID， 则Person.ID就是就是PersonSales表的外键， 如果Person表不存在某个ID，则PersonSales表不允许写入值； check 约束ALTER TABLE dbo.DocExc ADD ColumnD int NULL CONSTRAINT CHK_ColumnD_DocExc CHECK (ColumnD &gt; 10 AND ColumnD &lt; 50); 存储过程与定时任务CREATE PROCEDURE DBO.SP_NAMEBEGIN DECLARE @VAR INT; –DECLARE @VAR1 INT, VAR2 INT ,VAR 3 INT;END; 游标--声明游标 declare cur_name cursor for select ... --OPEN 语句填充结果集 open cur_name --FETCH 返回结果集中的行 fetch next from cur_name into @var while @@fetch_status = 0 @@fetch_status有3个值 ，模拟触发场景 0 fetch语句拿到结果集 -1 fetch语句失败或行不存在结果集中 -2 提取的行不存在 -9 游标未执行提取操作 --CLOSE 语句释放与游标关联的当前结果集 close cur_name --DEALLOCATE 语句释放游标所使用的资源 deallocate cur_name openquerydatabase link中会用到 常见的操作 --插入操作 insert into openquery ( link_name, 'select a,b,c,d from table' ) select '' a,'' b,'' c,'' d --更新操作 update openquery(link_name,'select col1 from table') set col1 = '' --删除操作 delete from openquery (link_name, 'select col from where ...' ) merge into 注意点： 1. openquery不能传参， 'select * from table where col = @var' 是不允许的， 但是， 'select * from table') where col=@var是允许的， 且 等效 2.","link":"/2023/09/10/sql-server/"},{"title":"概念积累","text":"概念1 中心化与去中心化 有中心，就有非中心 中心化：我们拿太阳系来说，太阳是中心，其他的星体是非中心，所有非中心直接或间接的围绕着太阳公转，因为需要依赖太阳来维持平衡 去中心化：我们拿打公交和打网约车来说， 公交的路线是固定的，我要去哪，得规划公交路线，考虑换乘，公交站点就是中心，而打网约车，从哪上车，去哪都是我说了算，车要以我为导向。 放到互联网行业，拿买菜来说，去菜市场买菜就是中心化，通过买菜软件买菜就是去中心化 去中心化本身也是中心化的一种形态，去中心化的实质是通过开拓多中心，弱化单一中心。 概念2 流程管理概念3 saas saas是互联网发展过程中的衍生出的一种软件服务模式。 saas的显著特点：租售服务 概念4 裂变工具 裂变手段： 群裂变、任务裂变 概念5 公域与私域私域： 品牌直连客户， 私域业态：小程序，品牌官网/app，社群等。 核心资产：用户和流量。 重要特征：产权自有，自主经营；线上线下一体化，全渠道数字化；直连用户。 在腾讯智慧零售课堂上看到的一个比较nice的观点： 用户价值水轮： 聚水流-&gt;凝水势-&gt;激水花（转折点）-&gt;变水力-&gt;促循环 公域 拓扑图中间件低代码低代码是一种快速设计和开发软件应用程序并且不需要复杂编码的手段。低代码所见即所得，通过可视化的建模来组装和配置应用程序，对于开发者而言，可以跳过基础架构，让开发速度提升，对于非开发者而言，不需要懂编程，也能实现自己想要的功能。 优点： 1. 省钱 2. 开发速度快 3. 维护简单 4. 提高生产力 odbc open database connection 开放数据库互联dll dynamic link library 动态链接库文件，又称应用程序拓展jre，jdk，jar，warjre ： java runtime environment，包含了JVM标准实现（bin）和JAVA核心类库（lib）。有jre，java程序才能在os上运行，强调运行能力 jdk ： 包含jre，还提供编译、运行等工具，如javac（编译，将源程序转字节码），java，javaw等 jar ： java archive，是归档文件，以zip构建，以jar为拓展名，jar文件时unicode编码的。JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。 war: war 包通常用于网站，它是一个可以直接运行的 web 模块 使用 jar 文件的目的是把类和相关的资源封装到压缩的归档文件中以方便调用。 而对于 war 文件来说，一个 war 文件就是一个 Web 应用程序。它包含 Servlet、HTML 页面、Java 类、图像文件，以及组成 Web 应用程序的其他资源，而不仅仅是类的归档文件。","link":"/2023/04/03/%E6%A6%82%E5%BF%B5%E7%A7%AF%E7%B4%AF/"},{"title":"英语拓展","text":"本文旨在提供日常英语，拓展用 人体结构相关的英语 head 头forehead 前额hair 头发 eyebrow 眉毛eyelashes 睫毛eye 眼睛eyelid 眼睑 ear 耳朵nose 鼻子nostril 鼻孔cheek 脸颊face 脸mouth 嘴moustache 指 上唇胡须beard 指 下颚胡须teeth 牙tongue 舌头lips 嘴唇chin 下颚 neck 脖子chest 胸膛shoulder 肩膀waist 腰belly 腹部back 后背upperarm 上臂forearm 前臂 hand 手finger 手指thumb 大拇指index finger 食指middle finger 中指ring finger 无名指pinky finger 小拇指palm 手掌 elbow 手肘arm 前臂hip 臀thigh 大腿knee 膝盖calf 小腿shin 胫部ankle 脚踝heel 脚后跟arch 足弓foot 脚toe 脚趾 brain 大脑vein 静脉throat 喉咙arteries动脉lung 肺heart 心脏liver 肝脏kidney 肾脏stomach 胃small intestine 小肠fatty tissue 脂肪组织muscles 肌肉large intestine 大肠bone 骨头skeleton 骨骼backbone 脊骨skull 颅骨rib 肋骨pelvis 盆骨kneecap 膝盖骨joint 关节windpipe 气管gall bladder 胆囊pancreas 胰腺spleen 脾脏bladder 膀胱penis 阴茎testicles 睾丸scroticles 阴囊urine 尿道ovary 卵巢womb 子宫vigina 阴道 12生肖，黄道12宫Zodiac 生肖，星座 Rat 鼠Ox 牛Tiger 虎Hare 兔Dragon 龙Snake 蛇Horse 马Sheep 羊Monkey 猴Rooster 鸡Dog 狗Boar 猪 Gemini 双子座Libra 天枰座Aquarius 水瓶座Sagittarius 射手座Pisces 双鱼座Taurus 金牛座Leo 狮子座Aries 白羊座Cancer 巨蟹座Capricorn 魔羯座Virgo 处女座Scorpio 天蝎座","link":"/2023/06/19/%E8%8B%B1%E8%AF%AD%E6%8B%93%E5%B1%95/"},{"title":"网络汇总","text":"熟悉网络模型及数据在网络模型各层间传递的方式 网络模型1. osi 7层模型 * 应用层： 网络服务与终端用户的接口 协议—————— http、ftp、tftp、smtp、snmp、dns、telnet、https、dhcp.. （交互数据为【报文】） * 表示层： 数据的表示、安全、压缩 * 会话层： 建立、管理、中止会话 * 运输层： 负责主机之间的进程的通信，提供通用的数据传输服务 协议—————— tcp（报文段） udp（用户数据报） * 网络层： 负责为分组交换网络上的主机提供通信服务 协议—————— IP （IP数据报）、arp协议、icmp协议、igmp协议 * 数据链路层： 封装成帧、透明传输、差错检测是数据链路层的3个基本问题。数据链路层使用的信道有点对点和广播2种。 协议：PPP 点对点协议、csma/cd协议 * 物理层：传输比特流数据，即0和1，它的主要任务是描述传输媒体的接口特性，接线器、电压、电压的意义、信号顺序。 数据在传输媒介中以串流方式传输，而计算机内则是并行传输的，因此在物理层还需要考虑传输方式切换，以便向上层取用。 数据在各网络模型间传递的方式，应用层到网络层，逐层加控制信息，变成下一层的数据单元，数据链路层在添加控制信息时，分别将首部和尾部加到数据单元，物理层传送比特流，从首部开始，到尾部结束。当发送方的比特流，通过路由器，到达接收方时，逐层拆分数据单元，将数据本身暴露给上层。 2. TCP/IP协议 应用层 运输层 网际层 网络接口层 3. 五层协议 应用层 运输层 网络层 数据链路层 物理层 协议的三要素1. 语法： 数据和控制信息的结构或格式 2. 语义： 控制信息的意义，如http协议的 get、put、delete 3. 同步： 事件实现顺序的详细说明 网络相关的行为中间设备1 . 转发器：物理层使用的中间设备，如中继器和集线器。 2 . 网桥、桥接器： 数据链路层使用的中间设备。 3 . 路由器： 网络层使用的中间设备。 4 . 网关： 网络层以上的中间设备，用网关连接2个不兼容的系统在高层进行协议的转化。 0.0.0.0 和 127.0.0.1 的区别0.0.0.0指的是本网络。 127.0.0.1是保留下来，用作本地软件环回测试本主机的进程之间的通信，不参与网络通信，接受到数据只在本地出应答。 netcat nc（或 netcat）实用程序可用于与 TCP 或 UDP 相关的各种任务。nc 可以打开 TCP 连接，发送 UDP 数据包，侦听任意 TCP 和 UDP 端口，执行端口扫描，以及处理 IPv4 和 IPv6。与 telnet(1) 不同，nc 精细地编写脚本，并将错误消息分隔到标准错误中，而不是将错误消息发送到标准输出。 nc 命令通常用于以下任务： 1. 构造客户机-服务器模型，在服务器启动端口监听nc，在客户机上连接服务器的端口。 2. 构建基本的数据传送模型。在连接的一端输入的任何信息都将输出到连接的另一端，并且可以轻松捕获输入和输出，以便模仿文件传送 3. 端口扫描 网关与路由的介绍 须知： IP地址的网络标识和主机标识 如果IP地址与子网掩码转换为2进制表示，做and运算，得出网络标识 将子网掩码取反，与IP地址做and运算，得出主机标识 如果验证2个主机是不是在同一个网段，则网络标识要一致。 IP地址是一个32位的二进制数，它由网络ID和主机ID两部份组成，用来在网络中唯一的标识的一台计算机。 网络ID用来标识计算机所处的网段； 主机ID用来标识计算机在网段中的位置。 IP地址通常用4组3位十进制数表示，中间用“.”分隔，比如，192.168.0.1 可用IP数量 = 可用IP地址 + 2 （去掉子网网络网址和子网的广播地址） 可用IP数量 = 主机标识的8位中，有x个0，就有2的x次方个地址 网关 网络有边界，即IP地址范围，在没有路由的情况下，网络间不能进行TCP/IP通信，即使它们连接在同一台交换机或集线器上 要想在网络见进行TCP/IP通信，则必须通过网关 本地网络主机A与数据包指向的目的主机B不在同一网段，则通过网关通信 通信方式为： A向本地网络网关发送数据包 本地网络网关转发给目的主机所在网络的网关 目的主机所在网络的网关转发给B 因此，需要设置好网关的IP地址，TCP/IP协议才能实现不能网络的相互通信 网关的IP地址可以是： 具有路由功能的设备的IP地址 具有路由功能的设备有路由器 启用了路由协议的服务器 代理服务器 路由器： 负责寻径的网络设备，在互联网中寻找通讯量最骚的一条网络路径提供给用户通信，用于连接多个逻辑上分开的网络 最佳的通信路径，路由器通过路由表为数据传输选择路径，按照最少时间算法或最右路径算法，利用路由表查找数据包从当前位置到目的地址的正确路径 查看本地路由表 cmd ： route pri-vn 、 netstat -r 、 ip route show 效果是一样的 IP地址与子网掩码一一对应，计算一个IP地址的方法为： IP地址的网络标识位占多少位，子网掩码就有多少位1，IP地址的主机标识占多少位，那么子网掩码就有多少位0. 按照常规的网段分类，A,B,C... A类网段： 网络地址占1个字节，也就是8位； 范围为 1.0.0.1 - 126.255.255.254 其中 10.0.0.0 -10.255.255.255是私有网段，127.x.x.x是保留地址 B类网段： 网络地址占2个字节，也就是16位； 范围位 128.0.0.1 - 191.31.255.255 其中 172.16.0.0 - 172.31.255.255是私有网段，169.254.x.x是保留地址 C类网段： 网阔地址占3个字节，也就是24位； 范围为 192.0.0.1 - 223.255.255.254 其中 192.168.x.x是私有网段， 组建局域网络要看设备的总数量，大于6万用A类地址，小于6W大于254按B类划分，否则按C类划分 明确了地址类别，也就明确了网络地址和主机地址的位数，同时就可以得出子网掩码，如要建立可以分配520个主机的网络，则按B类地址划分，520介于2的9次方和2的10次方之间，向上取整，所以主机地址占10位， 所以IP地址的主机位占10位，因此子网掩码的后10位为0，前22位为1，转换成10进制就是255.255.252.0 分析两个主机是否在一个网段，前提是他们的子网掩码要一致。 比较网络标识： 网络地址与子网掩码做与运算 主机标识： 子网掩码取反与IP地址做与运算 CIDR： 无类别域间路由 即 IP/n 意为前N位是网络标识，后（32-n）是主机可分配地址数量","link":"/2023/05/10/%E7%BD%91%E7%BB%9C%E6%B1%87%E6%80%BB/"}],"tags":[{"name":"环境搭建类","slug":"环境搭建类","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B1%BB/"},{"name":"Git，版本控制","slug":"Git，版本控制","link":"/tags/Git%EF%BC%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"概念相关","slug":"概念相关","link":"/tags/%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3/"}],"categories":[]}