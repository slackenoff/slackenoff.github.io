{"pages":[],"posts":[{"title":"博客搭建过程记录","text":"记录下hexo+github博客搭建过程 1. 第一步 github创建repo命名规范如： githubusername.github.io，不能自定义。 2. 第二步 本地配置主要有2部分，node+hex的环境搭建及部署，git+github的环境搭建及部署。 2.1 先安装node，node网址，配置环境变量 ，添加path 2.2 指定一个目录，进入终端，在该目录下执行 ： npm install -g hexo 默认这个目录就是hexo的根目录 2.3 本地服务配置命令 初始化： hexo init 生成默认的hexo模板： hexo g 启动本地预览服务，-p指定端口： hexo server -p 5000 （默认是4000） 2.4 默认的主题很简约，所以可以考虑改主题,这是 主题的官网地址 , 在根目录下，打卡bash终端， git clone [主题的github地址] themes/[主题名] 默认会下载到hexo的themes目录下，文件夹名为[主题名]，按照对应仓库下的readme.md文件，配置yml。 2.5 修改完，刷新本地的静态页面，观察效果 3.第三步 上传github仓库hexo d 上传配置到github的repo 3.1 git配置 git config user.email &quot;&quot; &lt;br&gt; git config user.name &quot;&quot; ssh-keygen -t rsa -C &quot;邮箱地址&quot; github设置中，修改ssh的绑定信息 ————————————-配置完成 4. 第四步 上传远端仓库 hexo clean hexo d -g 5. 至此就可以访问xxx.github.io了，如果不能正常访问，可以考虑主题文件缺失，或者配置有误，一般是低级错误导致的","link":"/2023/04/02/2023-4-2-%E9%9A%8F%E7%AC%94/"},{"title":"oracle基础","text":"oracle简介 ORACLE数据库系统是美国ORACLE公司（甲骨文）提供的以分布式数据库为核心的一组软件产品，是目前最流行的客户 / 服务器（client / server 或 B / S）体系结构的数据库之一。迄今为止ORACLE数据库是世界上使用最广泛的数据库管理系统。 oracle的特点 支持多用户、大事务量的事务处理 数据安全性和完整性控制（银行金融等行业比较看重这一点） 支持分布式数据处理 可移植性 oracle 体系结构 database结构 -- | 物理结构： 数据文件 *.dbf: 实际存储数据的文件 日志文件 *.log 控制文件 *.ctl 参数文件 InitSID.ora 逻辑结构： 表空间 tablespace： 数据库的最大逻辑存储结构，和数据文件对应，一个表空间可以有多个数据文件，但一个数据文件只能属于一个表空间。 段 segment 区 extent 块 block instance结构 -- | 内存结构：sga，包括share pool、db buffer cache、redo log buffer、large pool、java pool。pga程序跑起来时分配，服务于server process，存放服务器进程的数据和控制信息，独立于sga的内存区域。 进程结构：user process、server process 用户连接时即创建，background process：... 数据库相关概念 启动oracle前提应先启动instance. Instance=SGA+background process实例=内存分配+一组后台进程 sql基础 //关键字、表名和字段名都不区分大小写 =============================================既是操作数据，那必然先从数据类型开始 字符串： char 、varchar、varchar2、nvarchar、nvarchar2 数字： number（l,a）,遵循四舍五入 日期： date 注意日期格式 yyyy-mm-dd hh24:mi:ss mi区别于mm月份 clob和blob： 都属于lob，存储大字段类型， blob-binary large object 二进制大型对象，存储二进制字节流数据，如程序、图像、影音等 character large object 字符型大型对象，存储文本型数据，如xml，json =============================================sql 标准结构 标准sql结构及执行顺序 select [TOP|DISTINCT] [选择列表]|[*] from 数据源 [where 查询条件] [group by 分组条件] [having 过滤条件] [order by 排序条件 asc|desc nulls first|last]; 查看执行计划： explain plan FOR SELECT * FROM DEMO o; //step 1 SELECT * FROM table(DBMS_XPLAN.display()); //step2 =============================================sql 执行顺序 （5）select [（5-3）TOP|（5-2）DISTINCT] （5-1）[选择列表]|[*] （1）from 数据源 （2）[where 查询条件] （3）[group by 分组条件] （4）[having 过滤条件] （6）[order by asc|desc nulls first|last]; =============================================操作类型细分 1.DDL（DataDefinitionLanguage）：数据定义语言，用来定义数据库对象：库、表、列等； --drop、create、alter 2.DML（DataManipulationLanguage）：数据操作语言，用来定义数据库记录（数据）； --insert 、update 、delete 3.DQL（DataQueryLanguage）：数据查询语言，用来查询记录（数据）； --select *** from *** where *** 4.DCL（DataControlLanguage）：数据控制语言，用来定义访问权限和安全级别。--显式提交、隐式提交 控制方法：set autocommit on/off; --grant、rollback、commit =============================================条件判断、循环 =============================================对象：表、视图、序列、函数和存储过程、游标、触发器、索引、同义词 1. 表： 行*列 分区表 索引组织表 堆标: 默认数据表存储结构 创建方式： create table tablename（ col type， ... ） 2. 视图：基于表或者视图，提取或派生出数据 创建方式： create or replace view as [select ...] 3. 序列：生成唯一整数值的结构，不建议使用，因为序列存储在内存中，内存刷新 序列： create sequence seq_auto_add start with 1 --起始编号 nomaxvalue --不设置最大值上限，默认 10^28-1 nominvalue --不设置最小值下限，默认 -(10^27-1) increment by 1 --设置增长步长, 负数表示递减 cache 20; --默认缓存是20，第一次新增，则直接在缓存中写入20个数字，下一次新增直接获取缓存的数字；当缓存被刷新时，cache失效，所以不能保证自增序列的连续性。 --cache要满足表达式： select seq_auto_add.nextval from dual; CREATE TABLE ADD_TEST ( ID INT, NAME VARCHAR2(16) ) --插入序列的方式有多种 --第一种逐条插入 insert into table() values (seq_auto_add.nextval) --第二种触发器插入 create or replace trigger tri_tablename before insert on ADD_TEST for each row begin select ADD_TEST.ID into :new.seq_auto_add from dual; end; 4. 索引: 为经常作为查询条件的列，创建索引，可以显著提高查询效率，但使用索引会降低update、delete、insert效率。 oracle中，会自动为主键和唯一约束的列创建索引。 create index on tablename(col1,col2...coln) 5. 函数： 内嵌函数： * decode(exp，condition，result，default)，如果exp=condition,返回result，否则返回default，默认是null。 * coalesce（exp1,exp2,...,expn）,如果第一个值非空，那么返回，否则依次比较，直至找到一个非空的值，若所有表达式均为空，则返回null. * nvl（exp,replace_with）,如果exp为空，则用replace_with替代. * nvl2(exp,exp2,exp3),如果exp为null，返回exp3，否则返回exp2. * substr（str,a,b）,从str中截取从第a个字符串起，长度为b的字符串。如果a是负数，则|a|&gt;=b时，从a位置起，向后截取长度为b的字符串，否则，向后截取长度为|a|的字符串 * instr（str1，str2，b），返回str1中，str2第b次出现时的位置，b可以是负数。 * add() * minus() * SELECT LOWER('TR') FROM dual; --小写 * SELECT UPPER('TR') FROM dual; --大写 * round（） * sum（） * avg（） 自定义函数 规范： 带参数的存储过程： CREATE OR REPLACE PROCEDURE 存储过程名字( --输入参数 IN NUMBER, --输出参数 OUT NUMBER --可以有多个输入参数和输出参数 ) IS --这个区间可以用来定义变量和创建游标 BEGIN --执行游标或者执行语句 commit; --对上面的内容进行提交 exception//存储过程异常 when others then --异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定 /* 预定义异常： DUP_VAL_ON_INDEX、INVALID_CURSOR、INVALID_NUMBER、SELECT INTO【NO_DATA_FOUND、TOO_MANY_ROWS】、ZERO_DIVIDE、CURSOR_ALREADY_OPEN 自定义异常： RAISE_APPLICATION_ERROR(异常码-20000~ -20999，异常信息) exp_name EXCEPTION，声明； raise exp_name， 引发异常 */ rollback; dbms_output.put_line(sqlcode); dbms_output.put_line(substr(sqlerrm, 1, 512)); END 存储过程名字; 注意：其中参数IN表示输入参数，是参数的默认模式。 OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。 OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程 IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。 6.游标 Cursor is select … Open cursor Fetch cursor into 变量 Close cursor 游标的属性 FOUND/NOTFOUND/ISOPEN/ROWCOUNT 7.触发器 —— insert、update、delete操作执行在特定表上时，自动执行预定义的语句序列。 create or replace trigger tri_test before/after insert/update/delete on [object] for each row --默认是语句级触发,如果用了行级触发，那么要用old，new [follows] ==多个触发器时，执行先后顺序在此标注,不建议使用 when old 旧值/ new 新值 --此处old，new 不带 : begin 代码块; if deleting/updating/deleting then end if; --此处的引用old和new 需要带 : ，修改方式为 referencing new as alisa1 old as alias2； end;","link":"/2023/04/02/oracle%E5%9F%BA%E7%A1%80/"},{"title":"Git教程","text":"为什么要用版本控制 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。简单来说就是用于管理多人协同开发项目的技术 ● 实现跨区域多人协同开发 ● 追踪和记载一个或者多个文件的历史记录 ● 组织和保护你的源代码和文档 ● 统计工作量 ● 并行开发、提高开发效率 ● 跟踪记录整个软件的开发过程 ● 减轻开发人员的负担，节省时间，同时降低人为错误 版本控制的策略（都受制于网络）集中式版本控制：vss，cvs ，svn； 资源在中央服务器 分布式版本控制： git ； 资源在本地环境有中央服务器的副本 版本控制策略的优劣优势： 缺陷： 文件冲突 为什么选择Git来做版本控制优势 操作1. 仓库操作2. 文件操作3. 分支原理及操作： 分支是下载在本地的副本，使用分支可以减少文件冲突，以及修改合并操作，只需要关心最终合并。本质上是引用文件切换，head文件指向分支，分支指向具体提交的版本号。4. 标签5. 版本号： sha-1自动生成的40位（2位 文件夹+38位 文件名）6. 追溯文件： git cat-file 版本号具体的指令（远程仓库 -》 本地副本[工作区 -》 暂存区 -》 存储区域] -》 远程仓库）1. git init --创建一个空的本地仓库 2. git clone 仓库地址 --克隆仓库 3. git add --添加到暂存区 4. git status --查看暂存区比对信息 5. git commit -m 备注 --提交到存储区 6. git log --oneline --查看历史变更日志 7. git restore 或 git reset --hard 版本号 或者git revert 恢复文件 8. git branch 分支名 --创建分支 9. git branch -v 查看所有分支 10. git checkout -b 分支名 --创建并切换到本地分支 11. git branch -d 分支名 --删除本地分支 12. git merge 要合并的分支 --合并分支 13. git push origin --拉 14. git pull origin --推","link":"/2023/05/04/Git%E6%95%99%E7%A8%8B/"},{"title":"docker","text":"Docker采用客户端/服务器端架构, 使用远程API来管理和创建容器, 可以轻松的创建一个轻量级的, 可移植的容器.，它是一种容器技术。 容器： 容器是镜像的运行实体，是主机上运行的进程。 镜像： 镜像是一系列的只读文件，包含了容器运行时所有的基础文件和配置信息 ，是运行容器的基础。 相较于虚拟机，docker的交付速度更快，资源消耗更低，基本没有性能损耗。 传统虚拟机是虚拟出一个主机硬件, 并且运行一个完整的操作系统, 然后在这个系统上安装和运行软件,在物理机上，运行的虚拟机的数量很有限。 容器内的应用直接运行在宿主机的内核之上, 容器并没有自己的内核, 也不需要虚拟硬件, 相当轻量化，相较于虚拟机，容器可以运行几百个。 每个容器间是相互隔离, 每个容器内都要一个属于自己的独立文件系统, 独立的进程空间, 网络空间, 用户空间等, 所以在同一个宿主机上的多个容器之间彼此不会相互影响 Docker的三大理念就是build, ship, run. 一次构建，处处使用 Docker通过namespace和cgroup来提供容器的资源隔离与安全保障等, 所以Docker容器在运行时, 不需要类似虚拟机的额外资源开销, 因此可以大幅度提供资源利用率。 docker结构 client：通过client与daemon建立通信 daemon： daemon是系统进程，运行docker即运行daemon， 1. 用于接收并处理client发起的请求， 2. 管理所有的docker容器。 daemon的组成： server、engine and Job。 server接收请求后，通过路由寻找handler，并分发给对应handler处理请求 engine是docker的核心模块，存储容器信息，管理docker大部分job的执行 job是gengine内部的基本工作执行单元，如运行、创建、下载等动作 registry： 存储容器镜像的仓库。容器镜像是容器创建时用来初始化容器的文件系统内容。 与registry通信一般有3种动作， search 搜索、pull 下载 、push 上传 安装 dockerDocker支持64位版本的CentOS 7和CentOS 8及更高版本，它要求Linux内核版本不低于3.10。 1. 卸载旧的版本 (重新安装需要这一步) yum remove docker *** /// ***指docker相关的目录全部删掉 2. 配置仓库 先下载软件包： yum install -y yum-utils 国内的仓库： yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3. 安装 yum install -y docker-ce 下载过程中报错，会有建议执行命令，照着敲就好了。 4.启动docker systemctl start docker 或 service docker start 5.常见的Docker操作命令： 搜索仓库镜像：docker search --filter=stars=1000 镜像名 拉取镜像：docker pull 镜像名:tag 下载的镜像存放在 /var/lib/docker/image下 查看正在运行的容器：docker ps 查看所有容器：docker ps -a 删除容器：docker rm container_id 查看镜像：docker images 删除镜像：docker rmi image_id 启动（停止的）容器：docker start 容器ID 停止容器：docker stop 容器ID 重启容器：docker restart 容器ID 通过docker help命令来查看。 以tomcat为例使用docker部署并运行tomcat //docker的默认目录为/var/lib/docker //镜像下载目录为 /docker/image/overlay2 1. docker search tomcat: 版本信息 2. docker pull 下载查询出的tomcat-name镜像 3. docker images 查看镜像 4. docker run -d \\ --后台运行， -t为交互式运行 -p linux服务器端口：容器端口号 \\ --内外映射 --name 给容器起名字 tomcat 5. 查看tomcat运行情况， curl 0.0.0.0：端口号 ，会返回一串前端的html页面信息 这里拿到了404，查看tomcat的webapps目录，发现没有静态资源。 执行： docker exec -it container_id /bin/bash 进入容器内部 执行： ls 查看容器目录下的文件夹 执行： ls webapps 查看静态资源 添加静态资源，查看到webapps.dist下有静态资源 切到tomcat目录下， cp ./webapps.dist/* ./webapps 将资源复制 exit 退出容器目录 重新curl 6. 查看容器运行状态： docker ps （-a） 7. 关闭容器： docker stop container_id 8. 删除容器： docker rm container_id --可以用正则表达式或者管道函数，批量删除或者关闭容器 9. 镜像打包： docker save 镜像名：版本号 &gt; 名称.tar 10.镜像加载: docker load &lt; 镜像名.tar 容器资源分配问题 创建容器时，可能要考虑内存泄漏，out-of-memory，因此 使用-m参数来设置分配内存大小","link":"/2023/04/20/docker/"},{"title":"网络汇总","text":"网络模型1. osi 7层模型 * 应用层： 网络服务与终端用户的接口 协议—————— http、ftp、tftp、smtp、snmp、dns、telnet、https、dhcp.. （交互数据为【报文】） * 表示层： 数据的表示、安全、压缩 * 会话层： 建立、管理、中止会话 * 运输层： 负责主机之间的进程的通信，提供通用的数据传输服务 协议—————— tcp（报文段） udp（用户数据报） * 网络层： 负责为分组交换网络上的主机提供通信服务 协议—————— IP （IP数据报）、arp协议、icmp协议、igmp协议 * 数据链路层： 封装成帧、透明传输、差错检测是数据链路层的3个基本问题。数据链路层使用的信道有点对点和广播2种。 协议：PPP 点对点协议、csma/cd协议 * 物理层：传输比特流数据，即0和1，它的主要任务是描述传输媒体的接口特性，接线器、电压、电压的意义、信号顺序。 数据在传输媒介中以串流方式传输，而计算机内则是并行传输的，因此在物理层还需要考虑传输方式切换，以便向上层取用。 数据在各网络模型间传递的方式，应用层到网络层，逐层加控制信息，变成下一层的数据单元，数据链路层在添加控制信息时，分别将首部和尾部加到数据单元，物理层传送比特流，从首部开始，到尾部结束。当发送方的比特流，通过路由器，到达接收方时，逐层拆分数据单元，将数据本身暴露给上层。 2. TCP/IP协议 应用层 运输层 网际层 网络接口层 3. 五层协议 应用层 运输层 网络层 数据链路层 物理层 协议的三要素1. 语法： 数据和控制信息的结构或格式 2. 语义： 控制信息的意义，如http协议的 get、put、delete 3. 同步： 事件实现顺序的详细说明 网络相关的行为中间设备1 . 转发器：物理层使用的中间设备，如中继器和集线器。 2 . 网桥、桥接器： 数据链路层使用的中间设备。 3 . 路由器： 网络层使用的中间设备。 4 . 网关： 网络层以上的中间设备，用网关连接2个不兼容的系统在高层进行协议的转化。 0.0.0.0 和 127.0.0.1 的区别0.0.0.0指的是本网络。 127.0.0.1是保留下来，用作本地软件环回测试本主机的进程之间的通信，不参与网络通信，接受到数据只在本地出应答。 netcat nc（或 netcat）实用程序可用于与 TCP 或 UDP 相关的各种任务。nc 可以打开 TCP 连接，发送 UDP 数据包，侦听任意 TCP 和 UDP 端口，执行端口扫描，以及处理 IPv4 和 IPv6。与 telnet(1) 不同，nc 精细地编写脚本，并将错误消息分隔到标准错误中，而不是将错误消息发送到标准输出。 nc 命令通常用于以下任务： 1. 构造客户机-服务器模型，在服务器启动端口监听nc，在客户机上连接服务器的端口。 2. 构建基本的数据传送模型。在连接的一端输入的任何信息都将输出到连接的另一端，并且可以轻松捕获输入和输出，以便模仿文件传送 3. 端口扫描","link":"/2023/05/10/%E7%BD%91%E7%BB%9C%E6%B1%87%E6%80%BB/"},{"title":"linux命令","text":"linux是助推器，影响个人在IT赛道上的speed推荐一个我认为比较实用的查询网站linux命令搜索 辅助命令或常识 FHS File System Hierarchy Standard 文件系统层次结构标准 man hier bin 存放二进制的可执行程序 boot 系统引导时使用的文件 dev 存放设备文件，通过设备文件访问外部设备 etc 系统配置文件 home 所有用户的根目录，8个用户则有8个对应的/home/dir1..8 lib 存放根文件系统中的程序运行所需要的共享库及内核模块 mnt 临时文件系统的挂载点目录 media 即插即用型存储设备的挂载点，如cd，dvd opt 第三方软件的存放目录 proc 虚拟文件系统，存放当前内存的映射，再不重启机器的情况下管理内核 root 管理员用户目录 sbin 管理员才能访问的存放二进制可执行文件的目录，同bin srv 系统对外提供服务的目录 tmp 放置各种临时文件的目录 usr 存放系统应用程序 var 存放需要随时改变的文件，如系统日志，脱机工作目录等 文件类型及其颜色： 1. 普通文件 灰色 || 可执行文件 绿色 || 压缩文件 红色 ls -l 查看为 - 2. 目录文件 蓝色 ls -l 查看为 d 3. 设备文件 黄色 /dev/.. 块设备文件 b 硬盘软盘 随机访问设备 + 字符设备文件 c 串口、键盘 顺序访问设备 4. 链接文件 浅蓝色 ls -l 查看时，显示为 “|” 软链接（源文件的快捷方式，源动，链接动） 和 硬链接 （源文件别名，无论源动还是链接动，另一方都会改变），默认硬链接 。 5. 管道文件 棕色 用于进程间通信 ls -l 查看为 p 6. 套接字文件 紫色 用于网络通信 ls -l 查看为 s /文本 --查询文本 n/N --向后向前搜索 pageUp/Down --向上向下翻页 ctrl+C --结束执行 help command --查看命令文档 man [1..9] --查看不同手册页，存放路径 /usr/share/man/.. findmnt --查看已经挂载的文件系统、 df -Ph --显示磁盘剩余空间 fdisk -l --显示磁盘分区 firewall-cmd --list-all 显示防火墙规则 yum repolist --查看已启用的软件更新源 yum list installed --查看已安装的所有软件 yum check-update/yum list updates --查看可更新 localectl /etc/locale.conf 返回示例：LANG=&quot;zh_CN.UTF-8&quot; --control the system locale [语言环境] and keyboard layout [键盘模式] settings localectl status --查看本地语言环境设置 localectl set-locale LANG=&quot;&quot; --设置语言环境 localectl list-locales --查看常见的(官方用词known)语言环境 .. 硬件时钟（RTC）和系统时钟(SC): /etc/localtime RTC-主板上显示的时间 SC-内核时钟（操作系统实际使用，采用UTC时间） 国内CST 和 UTC（0时区） 差8个小时 timedatectl query or change system time and date settings timedatectl status timedatectl set-timezone ZONE=&quot;&quot; timedatectl set-time &quot;时间/年月/时间年月组合&quot; shutdown [shutdown -c 取消shutdown] [shutdown -k 发送关机计划提示，默认是分钟] 系统关闭断电 halt = shutdown -h 系统关闭不断电 poweroff = shutdown -P 系统关闭，断电 最终都是执行 systemctl[/usr/sbin] poweroff/reboot/halt shutdown -[options] [+]5[minutes] “警示语” 【似乎临近重启时间，每分钟都会提示】 包管理命令：apt、yum、dnf(fedora)yum介绍yum是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum语法： yum [选项] [参数]选项： -h：显示帮助信息； -y：对所有的提问都回答“yes”； -c：指定配置文件； -q：安静模式； -v：详细模式； -d：设置调试等级（0-10）； -e：设置错误等级（0-10）； -R：设置yum处理一个命令的最大等待时间； -C：完全从缓存中运行，而不去下载或者更新任何头文件。 参数： install：安装rpm软件包； update：更新rpm软件包； check-update：检查是否有可用的更新rpm软件包； remove：删除指定的rpm软件包； list：显示软件包的信息； search：检查软件包的信息； info：显示指定的rpm软件包的描述信息和概要信息； clean：清理yum过期的缓存，clean all； shell：进入yum的shell提示符； resolvedep：显示rpm软件包的依赖关系； localinstall：安装本地的rpm软件包； localupdate：显示本地rpm软件包进行更新； deplist：显示rpm软件包的所有依赖关系。 apt-get介绍apt-get命令 是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。 apt-get语法：apt-get [选项] 选项： apt-get install # 安装新包 apt-get remove # 卸载已安装的包（保留配置文件） apt-get purge # 卸载已安装的包（删除配置文件） apt-get update # 更新软件包列表 apt-get upgrade # 更新所有已安装的包 apt-get autoremove # 卸载已不需要的包依赖 apt-get dist-upgrade # 自动处理依赖包升级 apt-get autoclean # 将已经删除了的软件包的.deb安装文件从硬盘中删除掉 apt-get clean # 删除软件包的安装包 -c：指定配置文件。 – 执行命令重现的一对命令： script 以及scriptreplay centos重要的系统目录 1. cat /etc/os-release 查看系统版本 hostnamectl uname -a uname -r 2. cd /var/cache/yum 相关命令 yum makecache fast 将软件包信息提前在本地索引缓存，用来提高搜索安装软件的速度， yum clean all 清除索引缓存和下载包的缓存。 3. cd /etc/yum.repos.d 切换、查看yum镜像源的目录 vim xxx.repo 修改源配置文件 yum repolist 查看镜像源列表 源有： epel、extras、update、base 四种 4. 查看内核版本有三种方式： cat /proc/version uname -a uname -r 5. 用户配置信息丢失，登录非正常显示，如 bash-4.2 还原办法： 切换目录 cd /etc/skel ; 查看目录下的文件 ls -a; 复制 .bashrc .bash_profile 文件到 /root目录下 reboot 文件目录cmd 1. 查看 查看当前工作路径： pwd 查看文件和目录列表： ls -al 以长格式[l]显示当前路径下，全部[a]文件和目录（包含隐含文件、目录） 查找指定文件： find &quot;name.extend&quot; || find *.txt || find [查找的目录] -name '前缀*' 查看文件内容： cat/tac 文件名 分页查看文件内容： more/less 文件名 显示前、后n行内容： head/tail -n 文件名 统计文本内容： wc -lwm 文件名 [l 行 m 字符数 w word counts] 查看文件类型： file 文件名 2. 创建 touch file1，file2 创建2个空文件，0字节 echo &gt; file1 覆盖，没有则创建 echo &gt;&gt; file1 添加，没有则创建 3. 修改 vi mv name1 name2 将名为name1的文件或目录 改为name2 4. 删除 rm -f file{1，3，5} 强制删除 rm -r dir/ 提醒删除目录及其内容 rmdir 删除目录 5. 链接 ln a b 硬链接 b为链接 ln -s a b 软/符号链接 b为链接 6. 复制 cp [待复制内容] [目标目录] 时间戳： atime 最后访问 ls -lu，ctime 最后改变 ls -lc，mtime 最后修改 ls -lt 7. 打包 【多-&gt; 一，以便备份/传输】 、压缩 【大-&gt; 小 以便减少磁盘占用/传输】、解压 【小-&gt;大】 压缩格式 gzip，bzip2，xz tar -c 创建 -r 添加 -t 罗列 -u 更新旧内容 -x 解压 -v 打包解压进度 tar -cvf 包名.格式 [打包文件] 创建 tar -xvf 包名.格式 extract gzip 文件 压缩文件 gzip -d *.gz 解压文件 三剑客 grep 文本处理工具 与sed、awk实用命令 windows下的文件比对工具，如beyondCompare、ultraCompare （收费）， Winmerge（免费） ，或者文本编辑器下插件（如notepad++，vscode,sublime等）linux下diff命令，或者meld工具 diff 命令 diff【2个文件，不带参数时，描述如何调整第一个文件来与第二个文件想匹配】 -q或--brief // 仅显示有无差异，不显示详细的信息 如果不同，输出Files a and b differ -c // 显示全部内容，并标出不同之处， ！ + - *** 代表 第一个文件 --- 代表 第二个文件 ！ 需要在第一个文件修改一行或多行 + 需要在第一个文件添加行 - 需要在第一个文件删除行 注： 默认输出须知 diff [不带参] (a：添加， c：改变 ，d：删除） &lt; 开头的行表示来自第一个文件 &gt; 开头的行表示来自第二个文件 diff3【3个文件】 比较三个文件，将不同之处显示到标准输出 -A 注： ====表示文件全不相同 ====3表示 第3个文件与其他2个不同 sort命令 sort -r 按逆序输出排序结果 以行首字母为排序对象 -c 检查指定文件中的内容是否按字母顺序排序，不符合则输出 sort: 文件名：行号： disordr: 无序内容 awk命令sed命令chmod命令，配合ll命令查看文件权限 a) 第一位 文件类型 b) 权限前3位 文件所有者的权限 c) 权限中间3位 文件所属用户组的权限 d) 权限后3位 其他用户的权限 e) 其次是连接数 f) 所属用户 g) 所属用户组 h) 文件大小 i) 文件最后修改日期 j) 文件名 chmod 【a[所有人]u[文件拥有者]g[拥有者所属用户组]o[其他用户]】【+-=】【rwx】文件 chmod 【a[所有人]b[拥有者所属的用户组]c[其他用户]】【+-=】【r=4，w=2，x=1，-=0】 Kill -9 pid 与 kill -15 pid 9，是强制执行系统信号，pid进程接到信号必须结束运行，可能导致数据丢失或者终端无法恢复到正常状态等 15，先释放资源，再结束进程 echo 1. 普通终端输出，后面跟什么，输出什么 如： echo 123 终端输出123 2. 命令执行结果终端输出，输出命令执行结果 如： echo &quot;`ifconfig`&quot; 终端输出ifconfig网络信息,带 &quot;&quot; 等同于 ifconfig， 不带&quot;&quot;时，非格式化输出，不便于查看 3. 如果文件存在，则覆盖写入，否则先创建，再写入。 如： 1. echo &quot;echo &quot;`ifconfig`&quot;&quot;&gt; test.sh 2. cat test.sh 发现获取的是本地网络信息 3. 修改为 echo &quot;ifconfig&quot; &gt;test.sh 4. cat test.sh 发现只有一行ifconfig 5. 执行脚本报错，没有执行权限 6. 修改权限，chmod 777 test.sh 补充： 1. 修改某类型文件,多种类型用空格分开： chmod 777 *.txt *.html *.sh 2. 修改某个文件目录下的全部文件权限： chmod 777 /dir/dir1 或者切换到该目录 chmod（a） 777 * 3. 默认是 chmod是对所有人 即all， 否则需要写ugo+-=rwx 7.执行 ./test.sh，输出结果等效ifconfig if、ifconfig 配置和显示Linux内核中网络接口的网络参数 返回信息如： ens33: 连接类型、 硬件地址；网卡IP、广播地址、子网掩码；网卡启停，网线接入状态，是否支持组播，最大传输单元（字节） lo: 主机的回环地址，测试用 ifconfig ens33 up 启动指定网卡 ifconfig ens33 down 关闭指定网卡 ifconfig ens33 [点分十进制ip地址] netmask [子网掩码] broadcast [广播地址] hostname 查看和修改主机名 即 root@xxx 中的xxx，hostname的改动是临时的，永久改动要用hostnamectl hostnamectl status 查看当前主机名设置 hostnamectl set-hostname xxx 要重启 //主机名保存在 /etc/hostname中 route 本地路由表 destination： 可路由的IP gateway： 区分直连或非直连，直连0.0.0.0 非直连 显示网关IP genmask： 目标网络的掩码 metric： 路由开销，值越小，优先级越高 Iface： 从哪个网卡发出的请求 常用： route -n 不用代名词，以数字显示IP route add -net [] gw [] route del -net [] netstat -a : 显示所有活跃的网络连接 -r ： 路由表 等于 route -n -t ： tcp协议相关 -u ： udp协议相关 -l : 处于监听状态的网络连接及端口信息 -p ： 显示与网络连接相关联的进程号、进程名称信息 netstat -atlp/aulp netstat -r ps、 pstree ps aux |grep dockerd pstree -l -a -A pid grep","link":"/2023/04/06/linux%E5%91%BD%E4%BB%A4/"},{"title":"概念积累","text":"概念1 中心化与去中心化 有中心，就有非中心 中心化：我们拿太阳系来说，太阳是中心，其他的星体是非中心，所有非中心直接或间接的围绕着太阳公转，因为需要依赖太阳来维持平衡 去中心化：我们拿打公交和打网约车来说， 公交的路线是固定的，我要去哪，得规划公交路线，考虑换乘，公交站点就是中心，而打网约车，从哪上车，去哪都是我说了算，车要以我为导向。 放到互联网行业，拿买菜来说，去菜市场买菜就是中心化，通过买菜软件买菜就是去中心化 去中心化本身也是中心化的一种形态，去中心化的实质是通过开拓多中心，弱化单一中心。 概念2 流程管理概念3 saas saas是互联网发展过程中的衍生出的一种软件服务模式。 saas的显著特点：租售服务 概念4 裂变工具 裂变手段： 群裂变、任务裂变 概念5 公域与私域私域： 品牌直连客户， 私域业态：小程序，品牌官网/app，社群等。 核心资产：用户和流量。 重要特征：产权自有，自主经营；线上线下一体化，全渠道数字化；直连用户。 在腾讯智慧零售课堂上看到的一个比较nice的观点： 用户价值水轮： 聚水流-&gt;凝水势-&gt;激水花（转折点）-&gt;变水力-&gt;促循环 公域 拓扑图中间件低代码低代码是一种快速设计和开发软件应用程序并且不需要复杂编码的手段。低代码所见即所得，通过可视化的建模来组装和配置应用程序，对于开发者而言，可以跳过基础架构，让开发速度提升，对于非开发者而言，不需要懂编程，也能实现自己想要的功能。 优点： 1. 省钱 2. 开发速度快 3. 维护简单 4. 提高生产力","link":"/2023/04/03/%E6%A6%82%E5%BF%B5%E7%A7%AF%E7%B4%AF/"}],"tags":[{"name":"环境搭建类","slug":"环境搭建类","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%B1%BB/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"Git，版本控制","slug":"Git，版本控制","link":"/tags/Git%EF%BC%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"概念相关","slug":"概念相关","link":"/tags/%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3/"}],"categories":[]}